{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var isPromise = require('is-promise')\r\n\r\nvar nextTick\r\nif (typeof setImediate === 'function') nextTick = setImediate\r\nelse if (typeof process === 'object' && process && process.nextTick) nextTick = process.nextTick\r\nelse nextTick = function (cb) { setTimeout(cb, 0) }\r\n\r\nvar extensions = []\r\n\r\nmodule.exports = Promise\r\nfunction Promise(fn) {\r\n  if (!(this instanceof Promise)) {\r\n    return fn ? new Promise(fn) : defer()\r\n  }\r\n  if (typeof fn !== 'function') {\r\n    throw new TypeError('fn is not a function')\r\n  }\r\n\r\n  var state = {\r\n    isResolved: false,\r\n    isSettled: false,\r\n    isFulfilled: false,\r\n    value: null,\r\n    waiting: [],\r\n    running: false\r\n  }\r\n\r\n  function _resolve(val) {\r\n    resolve(state, val);\r\n  }\r\n  function _reject(err) {\r\n    reject(state, err);\r\n  }\r\n  this.then = function _then(onFulfilled, onRejected) {\r\n    return then(state, onFulfilled, onRejected);\r\n  }\r\n\r\n  _resolve.fulfill = deprecate(_resolve, 'resolver.fulfill(x)', 'resolve(x)')\r\n  _resolve.reject = deprecate(_reject, 'resolver.reject', 'reject(x)')\r\n\r\n  try {\r\n    fn(_resolve, _reject)\r\n  } catch (ex) {\r\n    _reject(ex)\r\n  }\r\n}\r\n\r\nfunction resolve(promiseState, value) {\r\n  if (promiseState.isResolved) return\r\n  if (isPromise(value)) {\r\n    assimilate(promiseState, value)\r\n  } else {\r\n    settle(promiseState, true, value)\r\n  }\r\n}\r\n\r\nfunction reject(promiseState, reason) {\r\n  if (promiseState.isResolved) return\r\n  settle(promiseState, false, reason)\r\n}\r\n\r\nfunction then(promiseState, onFulfilled, onRejected) {\r\n  return new Promise(function (resolve, reject) {\r\n    function done(next, skipTimeout) {\r\n      var callback = promiseState.isFulfilled ? onFulfilled : onRejected\r\n      if (typeof callback === 'function') {\r\n        function timeoutDone() {\r\n          var val\r\n          try {\r\n            val = callback(promiseState.value)\r\n          } catch (ex) {\r\n            reject(ex)\r\n            return next(true)\r\n          }\r\n          resolve(val)\r\n          next(true)\r\n        }\r\n        if (skipTimeout) timeoutDone()\r\n        else nextTick(timeoutDone)\r\n      } else if (promiseState.isFulfilled) {\r\n        resolve(promiseState.value)\r\n        next(skipTimeout)\r\n      } else {\r\n        reject(promiseState.value)\r\n        next(skipTimeout)\r\n      }\r\n    }\r\n    promiseState.waiting.push(done)\r\n    if (promiseState.isSettled && !promiseState.running) processQueue(promiseState)\r\n  })\r\n}\r\n\r\nfunction processQueue(promiseState) {\r\n  function next(skipTimeout) {\r\n    if (promiseState.waiting.length) {\r\n      promiseState.running = true\r\n      promiseState.waiting.shift()(next, skipTimeout)\r\n    } else {\r\n      promiseState.running = false\r\n    }\r\n  }\r\n  next(false)\r\n}\r\n\r\nfunction settle(promiseState, isFulfilled, value) {\r\n  if (promiseState.isSettled) return\r\n\r\n  promiseState.isResolved = promiseState.isSettled = true\r\n  promiseState.value = value\r\n  promiseState.isFulfilled = isFulfilled\r\n\r\n  processQueue(promiseState)\r\n}\r\n\r\nfunction assimilate(promiseState, thenable) {\r\n  try {\r\n    promiseState.isResolved = true\r\n    thenable.then(function (res) {\r\n      if (isPromise(res)) {\r\n        assimilate(promiseState, res)\r\n      } else {\r\n        settle(promiseState, true, res)\r\n      }\r\n    }, function (err) {\r\n      settle(promiseState, false, err)\r\n    })\r\n  } catch (ex) {\r\n    settle(promiseState, false, ex)\r\n  }\r\n}\r\n\r\nPromise.use = function (extension) {\r\n  extensions.push(extension)\r\n}\r\n\r\n\r\nfunction deprecate(method, name, alternative) {\r\n  return function () {\r\n    var err = new Error(name + ' is deprecated use ' + alternative)\r\n    if (typeof console !== 'undefined' && console && typeof console.warn === 'function') {\r\n      console.warn(name + ' is deprecated use ' + alternative)\r\n      if (err.stack) console.warn(err.stack)\r\n    } else {\r\n      nextTick(function () {\r\n        throw err\r\n      })\r\n    }\r\n    method.apply(this, arguments)\r\n  }\r\n}\r\nfunction defer() {\r\n  var err = new Error('promise.defer() is deprecated')\r\n  if (typeof console !== 'undefined' && console && typeof console.warn === 'function') {\r\n    console.warn('promise.defer() is deprecated')\r\n    if (err.stack) console.warn(err.stack)\r\n  } else {\r\n    nextTick(function () {\r\n      throw err\r\n    })\r\n  }\r\n  var resolver\r\n  var promise = new Promise(function (res) { resolver = res })\r\n  return {resolver: resolver, promise: promise}\r\n}"]}