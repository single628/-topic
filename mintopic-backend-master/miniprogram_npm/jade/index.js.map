{"version":3,"sources":["index.js","parser.js","lexer.js","utils.js","nodes/index.js","nodes/node.js","nodes/tag.js","nodes/attrs.js","nodes/block.js","inline-tags.js","nodes/code.js","nodes/each.js","nodes/case.js","nodes/text.js","nodes/mixin-block.js","nodes/mixin.js","nodes/filter.js","nodes/comment.js","nodes/literal.js","nodes/block-comment.js","nodes/doctype.js","filters.js","compiler.js","doctypes.js","runtime.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,AENA,AHSA,AENA;AHUA,AENA,AENA,AHSA,AENA;AHUA,AENA,AENA,AHSA,AENA;AHUA,AENA,AENA,ACHA,AJYA,AENA;AHUA,AENA,AENA,ACHA,AJYA,AENA;AHUA,AENA,AENA,ACHA,AJYA,AENA;AHUA,AENA,AENA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AENA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AENA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AKfA,AHSA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AKfA,AHSA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AKfA,AHSA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AKfA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AKfA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA;AHUA,AENA,AKfA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AHSA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AENA,ALeA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AENA,ALeA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AENA,ALeA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AENA,ACHA,ANkBA,ACHA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AENA,ACHA,ALeA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AENA,ACHA,ALeA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,ALeA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,ALeA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,ALeA,ALeA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,ALeA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,ALeA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,ALeA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AGTA,ARwBA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AGTA,ARwBA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AGTA,ARwBA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AGTA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AGTA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AGTA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AKfA,AFMA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AS3BA,APqBA,AKfA,ACHA,AIZA,AFMA,ACHA,AKfA,AFMA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,ACHA,AIZA,AFMA,ACHA,AKfA,AFMA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,ACHA,AIZA,AFMA,AOrBA,ANkBA,AKfA,AFMA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,ACHA,AIZA,AFMA,AOrBA,ANkBA,AKfA,AFMA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,ACHA,AIZA,AFMA,AOrBA,ANkBA,AKfA,AFMA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,ACHA,AIZA,AFMA,AOrBA,ANkBA,AKfA,AENA,AJYA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,ACHA,AIZA,AFMA,AOrBA,ANkBA,AKfA,AENA,AJYA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,ACHA,AIZA,AKfA,ANkBA,AKfA,AENA,AJYA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,ANkBA,AKfA,AENA,AJYA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,ANkBA,AKfA,AENA,AJYA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,ANkBA,AKfA,AENA,AJYA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AJYA,ACHA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,AOrBA,AZoCA,AENA;AHUA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,AOrBA,AZoCA,AENA;AkBrDA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,AOrBA,AZoCA;AoB3DA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,AOrBA,AZoCA;AoB3DA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,ALeA;AqB9DA,ADGA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,ALeA;AqB9DA,ADGA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,ALeA;AqB9DA,ADGA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,ALeA;AqB9DA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AIZA,AKfA,AGTA,AJYA,AENA,AHSA,AT2BA,ALeA;AqB9DA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AS3BA,AGTA,AJYA,AENA,AHSA,AT2BA,ALeA;AqB9DA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AS3BA,AGTA,AJYA,AENA,AHSA,AT2BA,ALeA;AqB9DA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AS3BA,AGTA,AJYA,AENA,AZoCA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AS3BA,AGTA,AFMA,AZoCA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AS3BA,AGTA,AFMA,AZoCA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AYpCA,Ad0CA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AYpCA,Ad0CA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AYpCA,Ad0CA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AYpCA,Ad0CA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AYpCA,Ad0CA,ALeA,AuBrEA;AFOA,ACHA,AFMA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AYpCA,Ad0CA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,AYpCA,AXiCA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AKfA,ACHA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,AFMA,ALeA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,AMlBA,APqBA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,ADGA,ArB+DA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA,AuBrEA;AFOA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,AtBkEA,AENA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;AqB9DA,ApB4DA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/*!\n * Jade\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Parser = require('./parser')\n  , Lexer = require('./lexer')\n  , Compiler = require('./compiler')\n  , runtime = require('./runtime')\n  , addWith = require('with')\n  , fs = require('fs')\n  , utils = require('./utils');\n\n/**\n * Expose self closing tags.\n */\n\n// FIXME: either stop exporting selfClosing in v2 or export the new object\n// form\nexports.selfClosing = Object.keys(require('void-elements'));\n\n/**\n * Default supported doctypes.\n */\n\nexports.doctypes = require('./doctypes');\n\n/**\n * Text filters.\n */\n\nexports.filters = require('./filters');\n\n/**\n * Utilities.\n */\n\nexports.utils = utils;\n\n/**\n * Expose `Compiler`.\n */\n\nexports.Compiler = Compiler;\n\n/**\n * Expose `Parser`.\n */\n\nexports.Parser = Parser;\n\n/**\n * Expose `Lexer`.\n */\n\nexports.Lexer = Lexer;\n\n/**\n * Nodes.\n */\n\nexports.nodes = require('./nodes');\n\n/**\n * Jade runtime helpers.\n */\n\nexports.runtime = runtime;\n\n/**\n * Template function cache.\n */\n\nexports.cache = {};\n\n/**\n * Parse the given `str` of jade and return a function body.\n *\n * @param {String} str\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nfunction parse(str, options){\n\n  if (options.lexer) {\n    console.warn('Using `lexer` as a local in render() is deprecated and '\n               + 'will be interpreted as an option in Jade 2.0.0');\n  }\n\n  // Parse\n  var parser = new (options.parser || Parser)(str, options.filename, options);\n  var tokens;\n  try {\n    // Parse\n    tokens = parser.parse();\n  } catch (err) {\n    parser = parser.context();\n    runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);\n  }\n\n  // Compile\n  var compiler = new (options.compiler || Compiler)(tokens, options);\n  var js;\n  try {\n    js = compiler.compile();\n  } catch (err) {\n    if (err.line && (err.filename || !options.filename)) {\n      runtime.rethrow(err, err.filename, err.line, parser.input);\n    } else {\n      if (err instanceof Error) {\n        err.message += '\\n\\nPlease report this entire error and stack trace to https://github.com/jadejs/jade/issues';\n      }\n      throw err;\n    }\n  }\n\n  // Debug compiler\n  if (options.debug) {\n    console.error('\\nCompiled Function:\\n\\n\\u001b[90m%s\\u001b[0m', js.replace(/^/gm, '  '));\n  }\n\n  var globals = [];\n\n  if (options.globals) {\n    globals = options.globals.slice();\n  }\n\n  globals.push('jade');\n  globals.push('jade_mixins');\n  globals.push('jade_interp');\n  globals.push('jade_debug');\n  globals.push('buf');\n\n  var body = ''\n    + 'var buf = [];\\n'\n    + 'var jade_mixins = {};\\n'\n    + 'var jade_interp;\\n'\n    + (options.self\n      ? 'var self = locals || {};\\n' + js\n      : addWith('locals || {}', '\\n' + js, globals)) + ';'\n    + 'return buf.join(\"\");';\n  return {body: body, dependencies: parser.dependencies};\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `str` is not set, the file specified in `options.filename` will be read.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param {Object} options\n * @param {String=} str\n * @return {Function}\n * @api private\n */\nfunction handleTemplateCache (options, str) {\n  var key = options.filename;\n  if (options.cache && exports.cache[key]) {\n    return exports.cache[key];\n  } else {\n    if (str === undefined) str = fs.readFileSync(options.filename, 'utf8');\n    var templ = exports.compile(str, options);\n    if (options.cache) exports.cache[key] = templ;\n    return templ;\n  }\n}\n\n/**\n * Compile a `Function` representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled\n       template, when it is explicitly `true`, the source code is included in\n       the compiled template for better accuracy.\n *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends\n *\n * @param {String} str\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\nexports.compile = function(str, options){\n  var options = options || {}\n    , filename = options.filename\n      ? utils.stringify(options.filename)\n      : 'undefined'\n    , fn;\n\n  str = String(str);\n\n  var parsed = parse(str, options);\n  if (options.compileDebug !== false) {\n    fn = [\n        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'\n      , 'try {'\n      , parsed.body\n      , '} catch (err) {'\n      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + utils.stringify(str) : '') + ');'\n      , '}'\n    ].join('\\n');\n  } else {\n    fn = parsed.body;\n  }\n  fn = new Function('locals, jade', fn)\n  var res = function(locals){ return fn(locals, Object.create(runtime)) };\n  if (options.client) {\n    res.toString = function () {\n      var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');\n      err.name = 'Warning';\n      console.error(err.stack || /* istanbul ignore next */ err.message);\n      return exports.compileClient(str, options);\n    };\n  }\n  res.dependencies = parsed.dependencies;\n  return res;\n};\n\n/**\n * Compile a JavaScript source representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` When it is `true`, the source code is included in\n *     the compiled template for better error messages.\n *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends\n *   - `name` the name of the resulting function (defaults to \"template\")\n *\n * @param {String} str\n * @param {Options} options\n * @return {Object}\n * @api public\n */\n\nexports.compileClientWithDependenciesTracked = function(str, options){\n  var options = options || {};\n  var name = options.name || 'template';\n  var filename = options.filename ? utils.stringify(options.filename) : 'undefined';\n  var fn;\n\n  str = String(str);\n  options.compileDebug = options.compileDebug ? true : false;\n  var parsed = parse(str, options);\n  if (options.compileDebug) {\n    fn = [\n        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'\n      , 'try {'\n      , parsed.body\n      , '} catch (err) {'\n      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + utils.stringify(str) + ');'\n      , '}'\n    ].join('\\n');\n  } else {\n    fn = parsed.body;\n  }\n\n  return {body: 'function ' + name + '(locals) {\\n' + fn + '\\n}', dependencies: parsed.dependencies};\n};\n\n/**\n * Compile a JavaScript source representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` When it is `true`, the source code is included in\n *     the compiled template for better error messages.\n *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends\n *   - `name` the name of the resulting function (defaults to \"template\")\n *\n * @param {String} str\n * @param {Options} options\n * @return {String}\n * @api public\n */\nexports.compileClient = function (str, options) {\n  return exports.compileClientWithDependenciesTracked(str, options).body;\n};\n\n/**\n * Compile a `Function` representation of the given jade file.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled\n       template, when it is explicitly `true`, the source code is included in\n       the compiled template for better accuracy.\n *\n * @param {String} path\n * @param {Options} options\n * @return {Function}\n * @api public\n */\nexports.compileFile = function (path, options) {\n  options = options || {};\n  options.filename = path;\n  return handleTemplateCache(options);\n};\n\n/**\n * Render the given `str` of jade.\n *\n * Options:\n *\n *   - `cache` enable template caching\n *   - `filename` filename required for `include` / `extends` and caching\n *\n * @param {String} str\n * @param {Object|Function} options or fn\n * @param {Function|undefined} fn\n * @returns {String}\n * @api public\n */\n\nexports.render = function(str, options, fn){\n  // support callback API\n  if ('function' == typeof options) {\n    fn = options, options = undefined;\n  }\n  if (typeof fn === 'function') {\n    var res\n    try {\n      res = exports.render(str, options);\n    } catch (ex) {\n      return fn(ex);\n    }\n    return fn(null, res);\n  }\n\n  options = options || {};\n\n  // cache requires .filename\n  if (options.cache && !options.filename) {\n    throw new Error('the \"filename\" option is required for caching');\n  }\n\n  return handleTemplateCache(options, str)(options);\n};\n\n/**\n * Render a Jade file at the given `path`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function|undefined} fn\n * @returns {String}\n * @api public\n */\n\nexports.renderFile = function(path, options, fn){\n  // support callback API\n  if ('function' == typeof options) {\n    fn = options, options = undefined;\n  }\n  if (typeof fn === 'function') {\n    var res\n    try {\n      res = exports.renderFile(path, options);\n    } catch (ex) {\n      return fn(ex);\n    }\n    return fn(null, res);\n  }\n\n  options = options || {};\n\n  options.filename = path;\n  return handleTemplateCache(options)(options);\n};\n\n\n/**\n * Compile a Jade file at the given `path` for use on the client.\n *\n * @param {String} path\n * @param {Object} options\n * @returns {String}\n * @api public\n */\n\nexports.compileFileClient = function(path, options){\n  var key = path + ':client';\n  options = options || {};\n\n  options.filename = path;\n\n  if (options.cache && exports.cache[key]) {\n    return exports.cache[key];\n  }\n\n  var str = fs.readFileSync(options.filename, 'utf8');\n  var out = exports.compileClient(str, options);\n  if (options.cache) exports.cache[key] = out;\n  return out;\n};\n\n/**\n * Express support.\n */\n\nexports.__express = function(path, options, fn) {\n  if(options.compileDebug == undefined && process.env.NODE_ENV === 'production') {\n    options.compileDebug = false;\n  }\n  exports.renderFile(path, options, fn);\n}\n","\n\nvar Lexer = require('./lexer');\nvar nodes = require('./nodes');\nvar utils = require('./utils');\nvar filters = require('./filters');\nvar path = require('path');\nvar constantinople = require('constantinople');\nvar parseJSExpression = require('character-parser').parseMax;\nvar extname = path.extname;\n\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nvar Parser = exports = module.exports = function Parser(str, filename, options){\n  //Strip any UTF-8 BOM off of the start of `str`, if it exists.\n  this.input = str.replace(/^\\uFEFF/, '');\n  this.lexer = new Lexer(this.input, filename);\n  this.filename = filename;\n  this.blocks = {};\n  this.mixins = {};\n  this.options = options;\n  this.contexts = [this];\n  this.inMixin = 0;\n  this.dependencies = [];\n  this.inBlock = 0;\n};\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n\n  /**\n   * Save original constructor\n   */\n\n  constructor: Parser,\n\n  /**\n   * Push `parser` onto the context stack,\n   * or pop and return a `Parser`.\n   */\n\n  context: function(parser){\n    if (parser) {\n      this.contexts.push(parser);\n    } else {\n      return this.contexts.pop();\n    }\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function(){\n    return this.lexer.advance();\n  },\n\n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  peek: function() {\n    return this.lookahead(1);\n  },\n\n  /**\n   * Return lexer lineno.\n   *\n   * @return {Number}\n   * @api private\n   */\n\n  line: function() {\n    return this.lexer.lineno;\n  },\n\n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n\n  lookahead: function(n){\n    return this.lexer.lookahead(n);\n  },\n\n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  parse: function(){\n    var block = new nodes.Block, parser;\n    block.line = 0;\n    block.filename = this.filename;\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        var next = this.peek();\n        var expr = this.parseExpr();\n        expr.filename = expr.filename || this.filename;\n        expr.line = next.line;\n        block.push(expr);\n      }\n    }\n\n    if (parser = this.extending) {\n      this.context(parser);\n      var ast = parser.parse();\n      this.context();\n\n      // hoist mixins\n      for (var name in this.mixins)\n        ast.unshift(this.mixins[name]);\n      return ast;\n    }\n\n    if (!this.extending && !this.included && Object.keys(this.blocks).length){\n      var blocks = [];\n      utils.walkAST(block, function (node) {\n        if (node.type === 'Block' && node.name) {\n          blocks.push(node.name);\n        }\n      });\n      Object.keys(this.blocks).forEach(function (name) {\n        if (blocks.indexOf(name) === -1 && !this.blocks[name].isSubBlock) {\n          console.warn('Warning: Unexpected block \"'\n                       + name\n                       + '\" '\n                       + ' on line '\n                       + this.blocks[name].line\n                       + ' of '\n                       + (this.blocks[name].filename)\n                       + '. This block is never used. This warning will be an error in v2.0.0');\n        }\n      }.bind(this));\n    }\n\n    return block;\n  },\n\n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  expect: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      throw new Error('expected \"' + type + '\", but got \"' + this.peek().type + '\"');\n    }\n  },\n\n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  accept: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n\n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n\n  parseExpr: function(){\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n      case 'mixin':\n        return this.parseMixin();\n      case 'block':\n        return this.parseBlock();\n      case 'mixin-block':\n        return this.parseMixinBlock();\n      case 'case':\n        return this.parseCase();\n      case 'extends':\n        return this.parseExtends();\n      case 'include':\n        return this.parseInclude();\n      case 'doctype':\n        return this.parseDoctype();\n      case 'filter':\n        return this.parseFilter();\n      case 'comment':\n        return this.parseComment();\n      case 'text':\n        return this.parseText();\n      case 'each':\n        return this.parseEach();\n      case 'code':\n        return this.parseCode();\n      case 'blockCode':\n        return this.parseBlockCode();\n      case 'call':\n        return this.parseCall();\n      case 'interpolation':\n        return this.parseInterpolation();\n      case 'yield':\n        this.advance();\n        var block = new nodes.Block;\n        block.yield = true;\n        return block;\n      case 'id':\n      case 'class':\n        var tok = this.advance();\n        this.lexer.defer(this.lexer.tok('tag', 'div'));\n        this.lexer.defer(tok);\n        return this.parseExpr();\n      default:\n        throw new Error('unexpected token \"' + this.peek().type + '\"');\n    }\n  },\n\n  /**\n   * Text\n   */\n\n  parseText: function(){\n    var tok = this.expect('text');\n    var tokens = this.parseInlineTagsInText(tok.val);\n    if (tokens.length === 1) return tokens[0];\n    var node = new nodes.Block;\n    for (var i = 0; i < tokens.length; i++) {\n      node.push(tokens[i]);\n    };\n    return node;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n\n  parseBlockExpansion: function(){\n    if (':' == this.peek().type) {\n      this.advance();\n      return new nodes.Block(this.parseExpr());\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n\n  parseCase: function(){\n    var val = this.expect('case').val;\n    var node = new nodes.Case(val);\n    node.line = this.line();\n\n    var block = new nodes.Block;\n    block.line = this.line();\n    block.filename = this.filename;\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'comment':\n        case 'newline':\n          this.advance();\n          break;\n        case 'when':\n          block.push(this.parseWhen());\n          break;\n        case 'default':\n          block.push(this.parseDefault());\n          break;\n        default:\n          throw new Error('Unexpected token \"' + this.peek().type\n                          + '\", expected \"when\", \"default\" or \"newline\"');\n      }\n    }\n    this.expect('outdent');\n\n    node.block = block;\n\n    return node;\n  },\n\n  /**\n   * when\n   */\n\n  parseWhen: function(){\n    var val = this.expect('when').val;\n    if (this.peek().type !== 'newline')\n      return new nodes.Case.When(val, this.parseBlockExpansion());\n    else\n      return new nodes.Case.When(val);\n  },\n\n  /**\n   * default\n   */\n\n  parseDefault: function(){\n    this.expect('default');\n    return new nodes.Case.When('default', this.parseBlockExpansion());\n  },\n\n  /**\n   * code\n   */\n\n  parseCode: function(afterIf){\n    var tok = this.expect('code');\n    var node = new nodes.Code(tok.val, tok.buffer, tok.escape);\n    var block;\n    node.line = this.line();\n\n    // throw an error if an else does not have an if\n    if (tok.isElse && !tok.hasIf) {\n      throw new Error('Unexpected else without if');\n    }\n\n    // handle block\n    block = 'indent' == this.peek().type;\n    if (block) {\n      node.block = this.block();\n    }\n\n    // handle missing block\n    if (tok.requiresBlock && !block) {\n      node.block = new nodes.Block();\n    }\n\n    // mark presense of if for future elses\n    if (tok.isIf && this.peek().isElse) {\n      this.peek().hasIf = true;\n    } else if (tok.isIf && this.peek().type === 'newline' && this.lookahead(2).isElse) {\n      this.lookahead(2).hasIf = true;\n    }\n\n    return node;\n  },\n\n  /**\n   * block code\n   */\n\n  parseBlockCode: function(){\n    var tok = this.expect('blockCode');\n    var node;\n    var body = this.peek();\n    var text;\n    if (body.type === 'pipeless-text') {\n      this.advance();\n      text = body.val.join('\\n');\n    } else {\n      text = '';\n    }\n      node = new nodes.Code(text, false, false);\n      return node;\n  },\n\n  /**\n   * comment\n   */\n\n  parseComment: function(){\n    var tok = this.expect('comment');\n    var node;\n\n    var block;\n    if (block = this.parseTextBlock()) {\n      node = new nodes.BlockComment(tok.val, block, tok.buffer);\n    } else {\n      node = new nodes.Comment(tok.val, tok.buffer);\n    }\n\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   * doctype\n   */\n\n  parseDoctype: function(){\n    var tok = this.expect('doctype');\n    var node = new nodes.Doctype(tok.val);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   * filter attrs? text-block\n   */\n\n  parseFilter: function(){\n    var tok = this.expect('filter');\n    var attrs = this.accept('attrs');\n    var block;\n\n    block = this.parseTextBlock() || new nodes.Block();\n\n    var options = {};\n    if (attrs) {\n      attrs.attrs.forEach(function (attribute) {\n        options[attribute.name] = constantinople.toConstant(attribute.val);\n      });\n    }\n\n    var node = new nodes.Filter(tok.val, block, options);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   * each block\n   */\n\n  parseEach: function(){\n    var tok = this.expect('each');\n    var node = new nodes.Each(tok.code, tok.val, tok.key);\n    node.line = this.line();\n    node.block = this.block();\n    if (this.peek().type == 'code' && this.peek().val == 'else') {\n      this.advance();\n      node.alternative = this.block();\n    }\n    return node;\n  },\n\n  /**\n   * Resolves a path relative to the template for use in\n   * includes and extends\n   *\n   * @param {String}  path\n   * @param {String}  purpose  Used in error messages.\n   * @return {String}\n   * @api private\n   */\n\n  resolvePath: function (path, purpose) {\n    var p = require('path');\n    var dirname = p.dirname;\n    var basename = p.basename;\n    var join = p.join;\n\n    if (path[0] !== '/' && !this.filename)\n      throw new Error('the \"filename\" option is required to use \"' + purpose + '\" with \"relative\" paths');\n\n    if (path[0] === '/' && !this.options.basedir)\n      throw new Error('the \"basedir\" option is required to use \"' + purpose + '\" with \"absolute\" paths');\n\n    path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);\n\n    if (basename(path).indexOf('.') === -1) path += '.jade';\n\n    return path;\n  },\n\n  /**\n   * 'extends' name\n   */\n\n  parseExtends: function(){\n    var fs = require('fs');\n\n    var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');\n    if ('.jade' != path.substr(-5)) path += '.jade';\n\n    this.dependencies.push(path);\n    var str = fs.readFileSync(path, 'utf8');\n    var parser = new this.constructor(str, path, this.options);\n    parser.dependencies = this.dependencies;\n\n    parser.blocks = this.blocks;\n    parser.included = this.included;\n    parser.contexts = this.contexts;\n    this.extending = parser;\n\n    // TODO: null node\n    return new nodes.Literal('');\n  },\n\n  /**\n   * 'block' name block\n   */\n\n  parseBlock: function(){\n    var block = this.expect('block');\n    var mode = block.mode;\n    var name = block.val.trim();\n\n    var line = block.line;\n\n    this.inBlock++;\n    block = 'indent' == this.peek().type\n      ? this.block()\n      : new nodes.Block(new nodes.Literal(''));\n    this.inBlock--;\n    block.name = name;\n    block.line = line;\n\n    var prev = this.blocks[name] || {prepended: [], appended: []}\n    if (prev.mode === 'replace') return this.blocks[name] = prev;\n\n    var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);\n\n    switch (mode) {\n      case 'append':\n        prev.appended = prev.parser === this ?\n                        prev.appended.concat(block.nodes) :\n                        block.nodes.concat(prev.appended);\n        break;\n      case 'prepend':\n        prev.prepended = prev.parser === this ?\n                         block.nodes.concat(prev.prepended) :\n                         prev.prepended.concat(block.nodes);\n        break;\n    }\n    block.nodes = allNodes;\n    block.appended = prev.appended;\n    block.prepended = prev.prepended;\n    block.mode = mode;\n    block.parser = this;\n\n    block.isSubBlock = this.inBlock > 0;\n\n    return this.blocks[name] = block;\n  },\n\n  parseMixinBlock: function () {\n    var block = this.expect('mixin-block');\n    if (!this.inMixin) {\n      throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');\n    }\n    return new nodes.MixinBlock();\n  },\n\n  /**\n   * include block?\n   */\n\n  parseInclude: function(){\n    var fs = require('fs');\n    var tok = this.expect('include');\n\n    var path = this.resolvePath(tok.val.trim(), 'include');\n    this.dependencies.push(path);\n    // has-filter\n    if (tok.filter) {\n      var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n      var options = {filename: path};\n      if (tok.attrs) {\n        tok.attrs.attrs.forEach(function (attribute) {\n          options[attribute.name] = constantinople.toConstant(attribute.val);\n        });\n      }\n      str = filters(tok.filter, str, options);\n      return new nodes.Literal(str);\n    }\n\n    // non-jade\n    if ('.jade' != path.substr(-5)) {\n      var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n      return new nodes.Literal(str);\n    }\n\n    var str = fs.readFileSync(path, 'utf8');\n    var parser = new this.constructor(str, path, this.options);\n    parser.dependencies = this.dependencies;\n\n    parser.blocks = utils.merge({}, this.blocks);\n    parser.included = true;\n\n    parser.mixins = this.mixins;\n\n    this.context(parser);\n    var ast = parser.parse();\n    this.context();\n    ast.filename = path;\n\n    if ('indent' == this.peek().type) {\n      ast.includeBlock().push(this.block());\n    }\n\n    return ast;\n  },\n\n  /**\n   * call ident block\n   */\n\n  parseCall: function(){\n    var tok = this.expect('call');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin = new nodes.Mixin(name, args, new nodes.Block, true);\n\n    this.tag(mixin);\n    if (mixin.code) {\n      mixin.block.push(mixin.code);\n      mixin.code = null;\n    }\n    if (mixin.block.isEmpty()) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n\n  parseMixin: function(){\n    var tok = this.expect('mixin');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin;\n\n    // definition\n    if ('indent' == this.peek().type) {\n      this.inMixin++;\n      mixin = new nodes.Mixin(name, args, this.block(), false);\n      this.mixins[name] = mixin;\n      this.inMixin--;\n      return mixin;\n    // call\n    } else {\n      return new nodes.Mixin(name, args, null, true);\n    }\n  },\n\n  parseInlineTagsInText: function (str) {\n    var line = this.line();\n\n    var match = /(\\\\)?#\\[((?:.|\\n)*)$/.exec(str);\n    if (match) {\n      if (match[1]) { // escape\n        var text = new nodes.Text(str.substr(0, match.index) + '#[');\n        text.line = line;\n        var rest = this.parseInlineTagsInText(match[2]);\n        if (rest[0].type === 'Text') {\n          text.val += rest[0].val;\n          rest.shift();\n        }\n        return [text].concat(rest);\n      } else {\n        var text = new nodes.Text(str.substr(0, match.index));\n        text.line = line;\n        var buffer = [text];\n        var rest = match[2];\n        var range = parseJSExpression(rest);\n        var inner = new Parser(range.src, this.filename, this.options);\n        buffer.push(inner.parse());\n        return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));\n      }\n    } else {\n      var text = new nodes.Text(str);\n      text.line = line;\n      return [text];\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n\n  parseTextBlock: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    var body = this.peek();\n    if (body.type !== 'pipeless-text') return;\n    this.advance();\n    block.nodes = body.val.reduce(function (accumulator, text) {\n      return accumulator.concat(this.parseInlineTagsInText(text));\n    }.bind(this), []);\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n\n  block: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    block.filename = this.filename;\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        var expr = this.parseExpr();\n        expr.filename = this.filename;\n        block.push(expr);\n      }\n    }\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseInterpolation: function(){\n    var tok = this.advance();\n    var tag = new nodes.Tag(tok.val);\n    tag.buffer = true;\n    return this.tag(tag);\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseTag: function(){\n    var tok = this.advance();\n    var tag = new nodes.Tag(tok.val);\n\n    tag.selfClosing = tok.selfClosing;\n\n    return this.tag(tag);\n  },\n\n  /**\n   * Parse tag.\n   */\n\n  tag: function(tag){\n    tag.line = this.line();\n\n    var seenAttrs = false;\n    // (attrs | class | id)*\n    out:\n      while (true) {\n        switch (this.peek().type) {\n          case 'id':\n          case 'class':\n            var tok = this.advance();\n            tag.setAttribute(tok.type, \"'\" + tok.val + \"'\");\n            continue;\n          case 'attrs':\n            if (seenAttrs) {\n              console.warn(this.filename + ', line ' + this.peek().line + ':\\nYou should not have jade tags with multiple attributes.');\n            }\n            seenAttrs = true;\n            var tok = this.advance();\n            var attrs = tok.attrs;\n\n            if (tok.selfClosing) tag.selfClosing = true;\n\n            for (var i = 0; i < attrs.length; i++) {\n              tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);\n            }\n            continue;\n          case '&attributes':\n            var tok = this.advance();\n            tag.addAttributes(tok.val);\n            break;\n          default:\n            break out;\n        }\n      }\n\n    // check immediate '.'\n    if ('dot' == this.peek().type) {\n      tag.textOnly = true;\n      this.advance();\n    }\n\n    // (text | code | ':')?\n    switch (this.peek().type) {\n      case 'text':\n        tag.block.push(this.parseText());\n        break;\n      case 'code':\n        tag.code = this.parseCode();\n        break;\n      case ':':\n        this.advance();\n        tag.block = new nodes.Block;\n        tag.block.push(this.parseExpr());\n        break;\n      case 'newline':\n      case 'indent':\n      case 'outdent':\n      case 'eos':\n      case 'pipeless-text':\n        break;\n      default:\n        throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`')\n    }\n\n    // newline*\n    while ('newline' == this.peek().type) this.advance();\n\n    // block?\n    if (tag.textOnly) {\n      tag.block = this.parseTextBlock() || new nodes.Block();\n    } else if ('indent' == this.peek().type) {\n      var block = this.block();\n      for (var i = 0, len = block.nodes.length; i < len; ++i) {\n        tag.block.push(block.nodes[i]);\n      }\n    }\n\n    return tag;\n  }\n};\n","\n\nvar utils = require('./utils');\nvar characterParser = require('character-parser');\n\n\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * @param {String} str\n * @param {String} filename\n * @api private\n */\n\nvar Lexer = module.exports = function Lexer(str, filename) {\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.filename = filename;\n  this.deferredTokens = [];\n  this.lastIndents = 0;\n  this.lineno = 1;\n  this.stash = [];\n  this.indentStack = [];\n  this.indentRe = null;\n  this.pipeless = false;\n};\n\n\nfunction assertExpression(exp) {\n  //this verifies that a JavaScript expression is valid\n  Function('', 'return (' + exp + ')');\n}\nfunction assertNestingCorrect(exp) {\n  //this verifies that code is properly nested, but allows\n  //invalid JavaScript such as the contents of `attributes`\n  var res = characterParser(exp)\n  if (res.isNesting()) {\n    throw new Error('Nesting must match on expression `' + exp + '`')\n  }\n}\n\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n\n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n\n  tok: function(type, val){\n    return {\n        type: type\n      , line: this.lineno\n      , val: val\n    }\n  },\n\n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n\n  consume: function(len){\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n\n  scan: function(regexp, type){\n    var captures;\n    if (captures = regexp.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok(type, captures[1]);\n    }\n  },\n\n  /**\n   * Defer the given `tok`.\n   *\n   * @param {Object} tok\n   * @api private\n   */\n\n  defer: function(tok){\n    this.deferredTokens.push(tok);\n  },\n\n  /**\n   * Lookahead `n` tokens.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n\n  lookahead: function(n){\n    var fetch = n - this.stash.length;\n    while (fetch-- > 0) this.stash.push(this.next());\n    return this.stash[--n];\n  },\n\n  /**\n   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.\n   *\n   * @return {Number}\n   * @api private\n   */\n\n  bracketExpression: function(skip){\n    skip = skip || 0;\n    var start = this.input[skip];\n    if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');\n    var end = ({'(': ')', '{': '}', '[': ']'})[start];\n    var range = characterParser.parseMax(this.input, {start: skip + 1});\n    if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);\n    return range;\n  },\n\n  /**\n   * Stashed token.\n   */\n\n  stashed: function() {\n    return this.stash.length\n      && this.stash.shift();\n  },\n\n  /**\n   * Deferred token.\n   */\n\n  deferred: function() {\n    return this.deferredTokens.length\n      && this.deferredTokens.shift();\n  },\n\n  /**\n   * end-of-source.\n   */\n\n  eos: function() {\n    if (this.input.length) return;\n    if (this.indentStack.length) {\n      this.indentStack.shift();\n      return this.tok('outdent');\n    } else {\n      return this.tok('eos');\n    }\n  },\n\n  /**\n   * Blank line.\n   */\n\n  blank: function() {\n    var captures;\n    if (captures = /^\\n *\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      ++this.lineno;\n      if (this.pipeless) return this.tok('text', '');\n      return this.next();\n    }\n  },\n\n  /**\n   * Comment.\n   */\n\n  comment: function() {\n    var captures;\n    if (captures = /^\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      this.pipeless = true;\n      return tok;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n\n  interpolation: function() {\n    if (/^#\\{/.test(this.input)) {\n      var match = this.bracketExpression(1);\n\n      this.consume(match.end + 1);\n      return this.tok('interpolation', match.src);\n    }\n  },\n\n  /**\n   * Tag.\n   */\n\n  tag: function() {\n    var captures;\n    if (captures = /^(\\w[-:\\w]*)(\\/?)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok, name = captures[1];\n      if (':' == name[name.length - 1]) {\n        name = name.slice(0, -1);\n        tok = this.tok('tag', name);\n        this.defer(this.tok(':'));\n        if (this.input[0] !== ' ') {\n          console.warn('Warning: space required after `:` on line ' + this.lineno +\n              ' of jade file \"' + this.filename + '\"');\n        }\n        while (' ' == this.input[0]) this.input = this.input.substr(1);\n      } else {\n        tok = this.tok('tag', name);\n      }\n      tok.selfClosing = !!captures[2];\n      return tok;\n    }\n  },\n\n  /**\n   * Filter.\n   */\n\n  filter: function() {\n    var tok = this.scan(/^:([\\w\\-]+)/, 'filter');\n    if (tok) {\n      this.pipeless = true;\n      return tok;\n    }\n  },\n\n  /**\n   * Doctype.\n   */\n\n  doctype: function() {\n    if (this.scan(/^!!! *([^\\n]+)?/, 'doctype')) {\n      throw new Error('`!!!` is deprecated, you must now use `doctype`');\n    }\n    var node = this.scan(/^(?:doctype) *([^\\n]+)?/, 'doctype');\n    if (node && node.val && node.val.trim() === '5') {\n      throw new Error('`doctype 5` is deprecated, you must now use `doctype html`');\n    }\n    return node;\n  },\n\n  /**\n   * Id.\n   */\n\n  id: function() {\n    return this.scan(/^#([\\w-]+)/, 'id');\n  },\n\n  /**\n   * Class.\n   */\n\n  className: function() {\n    return this.scan(/^\\.([\\w-]+)/, 'class');\n  },\n\n  /**\n   * Text.\n   */\n\n  text: function() {\n    return this.scan(/^(?:\\| ?| )([^\\n]+)/, 'text') ||\n      this.scan(/^\\|?( )/, 'text') ||\n      this.scan(/^(<[^\\n]*)/, 'text');\n  },\n\n  textFail: function () {\n    var tok;\n    if (tok = this.scan(/^([^\\.\\n][^\\n]+)/, 'text')) {\n      console.warn('Warning: missing space before text for line ' + this.lineno +\n          ' of jade file \"' + this.filename + '\"');\n      return tok;\n    }\n  },\n\n  /**\n   * Dot.\n   */\n\n  dot: function() {\n    var match;\n    if (match = this.scan(/^\\./, 'dot')) {\n      this.pipeless = true;\n      return match;\n    }\n  },\n\n  /**\n   * Extends.\n   */\n\n  \"extends\": function() {\n    return this.scan(/^extends? +([^\\n]+)/, 'extends');\n  },\n\n  /**\n   * Block prepend.\n   */\n\n  prepend: function() {\n    var captures;\n    if (captures = /^prepend +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'prepend'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Block append.\n   */\n\n  append: function() {\n    var captures;\n    if (captures = /^append +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'append'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Block.\n   */\n\n  block: function() {\n    var captures;\n    if (captures = /^block\\b *(?:(prepend|append) +)?([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = captures[1] || 'replace'\n        , name = captures[2]\n        , tok = this.tok('block', name);\n\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Mixin Block.\n   */\n\n  mixinBlock: function() {\n    var captures;\n    if (captures = /^block[ \\t]*(\\n|$)/.exec(this.input)) {\n      this.consume(captures[0].length - captures[1].length);\n      return this.tok('mixin-block');\n    }\n  },\n\n  /**\n   * Yield.\n   */\n\n  'yield': function() {\n    return this.scan(/^yield */, 'yield');\n  },\n\n  /**\n   * Include.\n   */\n\n  include: function() {\n    return this.scan(/^include +([^\\n]+)/, 'include');\n  },\n\n  /**\n   * Include with filter\n   */\n\n  includeFiltered: function() {\n    var captures;\n    if (captures = /^include:([\\w\\-]+)([\\( ])/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      var filter = captures[1];\n      var attrs = captures[2] === '(' ? this.attrs() : null;\n      if (!(captures[2] === ' ' || this.input[0] === ' ')) {\n        throw new Error('expected space after include:filter but got ' + utils.stringify(this.input[0]));\n      }\n      captures = /^ *([^\\n]+)/.exec(this.input);\n      if (!captures || captures[1].trim() === '') {\n        throw new Error('missing path for include:filter');\n      }\n      this.consume(captures[0].length);\n      var path = captures[1];\n      var tok = this.tok('include', path);\n      tok.filter = filter;\n      tok.attrs = attrs;\n      return tok;\n    }\n  },\n\n  /**\n   * Case.\n   */\n\n  \"case\": function() {\n    return this.scan(/^case +([^\\n]+)/, 'case');\n  },\n\n  /**\n   * When.\n   */\n\n  when: function() {\n    return this.scan(/^when +([^:\\n]+)/, 'when');\n  },\n\n  /**\n   * Default.\n   */\n\n  \"default\": function() {\n    return this.scan(/^default */, 'default');\n  },\n\n  /**\n   * Call mixin.\n   */\n\n  call: function(){\n\n    var tok, captures;\n    if (captures = /^\\+(\\s*)(([-\\w]+)|(#\\{))/.exec(this.input)) {\n      // try to consume simple or interpolated call\n      if (captures[3]) {\n        // simple call\n        this.consume(captures[0].length);\n        tok = this.tok('call', captures[3]);\n      } else {\n        // interpolated call\n        var match = this.bracketExpression(2 + captures[1].length);\n        this.consume(match.end + 1);\n        assertExpression(match.src);\n        tok = this.tok('call', '#{'+match.src+'}');\n      }\n\n      // Check for args (not attributes)\n      if (captures = /^ *\\(/.exec(this.input)) {\n        var range = this.bracketExpression(captures[0].length - 1);\n        if (!/^\\s*[-\\w]+ *=/.test(range.src)) { // not attributes\n          this.consume(range.end + 1);\n          tok.args = range.src;\n        }\n        if (tok.args) {\n          assertExpression('[' + tok.args + ']');\n        }\n      }\n\n      return tok;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n\n  mixin: function(){\n    var captures;\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))? */.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2];\n      return tok;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n\n  conditional: function() {\n    var captures;\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1]\n      var js = captures[2];\n      var isIf = false;\n      var isElse = false;\n\n      switch (type) {\n        case 'if':\n          assertExpression(js)\n          js = 'if (' + js + ')';\n          isIf = true;\n          break;\n        case 'unless':\n          assertExpression(js)\n          js = 'if (!(' + js + '))';\n          isIf = true;\n          break;\n        case 'else if':\n          assertExpression(js)\n          js = 'else if (' + js + ')';\n          isIf = true;\n          isElse = true;\n          break;\n        case 'else':\n          if (js && js.trim()) {\n            throw new Error('`else` cannot have a condition, perhaps you meant `else if`');\n          }\n          js = 'else';\n          isElse = true;\n          break;\n      }\n      var tok = this.tok('code', js);\n      tok.isElse = isElse;\n      tok.isIf = isIf;\n      tok.requiresBlock = true;\n      return tok;\n    }\n  },\n\n  /**\n   * While.\n   */\n\n  \"while\": function() {\n    var captures;\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      assertExpression(captures[1])\n      var tok = this.tok('code', 'while (' + captures[1] + ')');\n      tok.requiresBlock = true;\n      return tok;\n    }\n  },\n\n  /**\n   * Each.\n   */\n\n  each: function() {\n    var captures;\n    if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || '$index';\n      assertExpression(captures[3])\n      tok.code = captures[3];\n      return tok;\n    }\n  },\n\n  /**\n   * Code.\n   */\n\n  code: function() {\n    var captures;\n    if (captures = /^(!?=|-)[ \\t]*([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var flags = captures[1];\n      captures[1] = captures[2];\n      var tok = this.tok('code', captures[1]);\n      tok.escape = flags.charAt(0) === '=';\n      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';\n      if (tok.buffer) assertExpression(captures[1])\n      return tok;\n    }\n  },\n\n\n  /**\n   * Block code.\n   */\n\n  blockCode: function() {\n    var captures;\n    if (captures = /^-\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      var tok = this.tok('blockCode');\n      this.pipeless = true;\n      return tok;\n    }\n  },\n\n  /**\n   * Attributes.\n   */\n\n  attrs: function() {\n    if ('(' == this.input.charAt(0)) {\n      var index = this.bracketExpression().end\n        , str = this.input.substr(1, index-1)\n        , tok = this.tok('attrs');\n\n      assertNestingCorrect(str);\n\n      var quote = '';\n      var interpolate = function (attr) {\n        return attr.replace(/(\\\\)?#\\{(.+)/g, function(_, escape, expr){\n          if (escape) return _;\n          try {\n            var range = characterParser.parseMax(expr);\n            if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));\n            assertExpression(range.src)\n            return quote + \" + (\" + range.src + \") + \" + quote + interpolate(expr.substr(range.end + 1));\n          } catch (ex) {\n            return _.substr(0, 2) + interpolate(_.substr(2));\n          }\n        });\n      }\n\n      this.consume(index + 1);\n      tok.attrs = [];\n\n      var escapedAttr = true\n      var key = '';\n      var val = '';\n      var interpolatable = '';\n      var state = characterParser.defaultState();\n      var loc = 'key';\n      var isEndOfAttribute = function (i) {\n        if (key.trim() === '') return false;\n        if (i === str.length) return true;\n        if (loc === 'key') {\n          if (str[i] === ' ' || str[i] === '\\n') {\n            for (var x = i; x < str.length; x++) {\n              if (str[x] != ' ' && str[x] != '\\n') {\n                if (str[x] === '=' || str[x] === '!' || str[x] === ',') return false;\n                else return true;\n              }\n            }\n          }\n          return str[i] === ','\n        } else if (loc === 'value' && !state.isNesting()) {\n          try {\n            assertExpression(val);\n            if (str[i] === ' ' || str[i] === '\\n') {\n              for (var x = i; x < str.length; x++) {\n                if (str[x] != ' ' && str[x] != '\\n') {\n                  if (characterParser.isPunctuator(str[x]) && str[x] != '\"' && str[x] != \"'\") return false;\n                  else return true;\n                }\n              }\n            }\n            return str[i] === ',';\n          } catch (ex) {\n            return false;\n          }\n        }\n      }\n\n      this.lineno += str.split(\"\\n\").length - 1;\n\n      for (var i = 0; i <= str.length; i++) {\n        if (isEndOfAttribute(i)) {\n          val = val.trim();\n          if (val) assertExpression(val)\n          key = key.trim();\n          key = key.replace(/^['\"]|['\"]$/g, '');\n          tok.attrs.push({\n            name: key,\n            val: '' == val ? true : val,\n            escaped: escapedAttr\n          });\n          key = val = '';\n          loc = 'key';\n          escapedAttr = false;\n        } else {\n          switch (loc) {\n            case 'key-char':\n              if (str[i] === quote) {\n                loc = 'key';\n                if (i + 1 < str.length && [' ', ',', '!', '=', '\\n'].indexOf(str[i + 1]) === -1)\n                  throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\\\n`, `,`, `!` or `=`');\n              } else {\n                key += str[i];\n              }\n              break;\n            case 'key':\n              if (key === '' && (str[i] === '\"' || str[i] === \"'\")) {\n                loc = 'key-char';\n                quote = str[i];\n              } else if (str[i] === '!' || str[i] === '=') {\n                escapedAttr = str[i] !== '!';\n                if (str[i] === '!') i++;\n                if (str[i] !== '=') throw new Error('Unexpected character ' + str[i] + ' expected `=`');\n                loc = 'value';\n                state = characterParser.defaultState();\n              } else {\n                key += str[i]\n              }\n              break;\n            case 'value':\n              state = characterParser.parseChar(str[i], state);\n              if (state.isString()) {\n                loc = 'string';\n                quote = str[i];\n                interpolatable = str[i];\n              } else {\n                val += str[i];\n              }\n              break;\n            case 'string':\n              state = characterParser.parseChar(str[i], state);\n              interpolatable += str[i];\n              if (!state.isString()) {\n                loc = 'value';\n                val += interpolate(interpolatable);\n              }\n              break;\n          }\n        }\n      }\n\n      if ('/' == this.input.charAt(0)) {\n        this.consume(1);\n        tok.selfClosing = true;\n      }\n\n      return tok;\n    }\n  },\n\n  /**\n   * &attributes block\n   */\n  attributesBlock: function () {\n    var captures;\n    if (/^&attributes\\b/.test(this.input)) {\n      this.consume(11);\n      var args = this.bracketExpression();\n      this.consume(args.end + 1);\n      return this.tok('&attributes', args.src);\n    }\n  },\n\n  /**\n   * Indent | Outdent | Newline.\n   */\n\n  indent: function() {\n    var captures, re;\n\n    // established regexp\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input);\n    // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input);\n\n      // spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    if (captures) {\n      var tok\n        , indents = captures[1].length;\n\n      ++this.lineno;\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        throw new Error('Invalid indentation, you can use tabs or spaces but not both');\n      }\n\n      // blank line\n      if ('\\n' == this.input[0]) {\n        this.pipeless = false;\n        return this.tok('newline');\n      }\n\n      // outdent\n      if (this.indentStack.length && indents < this.indentStack[0]) {\n        while (this.indentStack.length && this.indentStack[0] > indents) {\n          this.stash.push(this.tok('outdent'));\n          this.indentStack.shift();\n        }\n        tok = this.stash.pop();\n      // indent\n      } else if (indents && indents != this.indentStack[0]) {\n        this.indentStack.unshift(indents);\n        tok = this.tok('indent', indents);\n      // newline\n      } else {\n        tok = this.tok('newline');\n      }\n\n      this.pipeless = false;\n      return tok;\n    }\n  },\n\n  /**\n   * Pipe-less text consumed only when\n   * pipeless is true;\n   */\n\n  pipelessText: function() {\n    if (!this.pipeless) return;\n    var captures, re;\n\n    // established regexp\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input);\n    // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input);\n\n      // spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    var indents = captures && captures[1].length;\n    if (indents && (this.indentStack.length === 0 || indents > this.indentStack[0])) {\n      var indent = captures[1];\n      var line;\n      var tokens = [];\n      var isMatch;\n      do {\n        // text has `\\n` as a prefix\n        var i = this.input.substr(1).indexOf('\\n');\n        if (-1 == i) i = this.input.length - 1;\n        var str = this.input.substr(1, i);\n        isMatch = str.substr(0, indent.length) === indent || !str.trim();\n        if (isMatch) {\n          // consume test along with `\\n` prefix if match\n          this.consume(str.length + 1);\n          ++this.lineno;\n          tokens.push(str.substr(indent.length));\n        }\n      } while(this.input.length && isMatch);\n      while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();\n      return this.tok('pipeless-text', tokens);\n    }\n  },\n\n  /**\n   * ':'\n   */\n\n  colon: function() {\n    var good = /^: +/.test(this.input);\n    var res = this.scan(/^: */, ':');\n    if (res && !good) {\n      console.warn('Warning: space required after `:` on line ' + this.lineno +\n          ' of jade file \"' + this.filename + '\"');\n    }\n    return res;\n  },\n\n  fail: function () {\n    throw new Error('unexpected text ' + this.input.substr(0, 5));\n  },\n\n  /**\n   * Return the next token object, or those\n   * previously stashed by lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function(){\n    return this.stashed()\n      || this.next();\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  next: function() {\n    return this.deferred()\n      || this.blank()\n      || this.eos()\n      || this.pipelessText()\n      || this.yield()\n      || this.doctype()\n      || this.interpolation()\n      || this[\"case\"]()\n      || this.when()\n      || this[\"default\"]()\n      || this[\"extends\"]()\n      || this.append()\n      || this.prepend()\n      || this.block()\n      || this.mixinBlock()\n      || this.include()\n      || this.includeFiltered()\n      || this.mixin()\n      || this.call()\n      || this.conditional()\n      || this.each()\n      || this[\"while\"]()\n      || this.tag()\n      || this.filter()\n      || this.blockCode()\n      || this.code()\n      || this.id()\n      || this.className()\n      || this.attrs()\n      || this.attributesBlock()\n      || this.indent()\n      || this.text()\n      || this.comment()\n      || this.colon()\n      || this.dot()\n      || this.textFail()\n      || this.fail();\n  }\n};\n","\n\n/**\n * Merge `b` into `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object}\n * @api public\n */\n\nexports.merge = function(a, b) {\n  for (var key in b) a[key] = b[key];\n  return a;\n};\n\nexports.stringify = function(str) {\n  return JSON.stringify(str)\n             .replace(/\\u2028/g, '\\\\u2028')\n             .replace(/\\u2029/g, '\\\\u2029');\n};\n\nexports.walkAST = function walkAST(ast, before, after) {\n  before && before(ast);\n  switch (ast.type) {\n    case 'Block':\n      ast.nodes.forEach(function (node) {\n        walkAST(node, before, after);\n      });\n      break;\n    case 'Case':\n    case 'Each':\n    case 'Mixin':\n    case 'Tag':\n    case 'When':\n    case 'Code':\n      ast.block && walkAST(ast.block, before, after);\n      break;\n    case 'Attrs':\n    case 'BlockComment':\n    case 'Comment':\n    case 'Doctype':\n    case 'Filter':\n    case 'Literal':\n    case 'MixinBlock':\n    case 'Text':\n      break;\n    default:\n      throw new Error('Unexpected node type ' + ast.type);\n      break;\n  }\n  after && after(ast);\n};\n","\n\nexports.Node = require('./node');\nexports.Tag = require('./tag');\nexports.Code = require('./code');\nexports.Each = require('./each');\nexports.Case = require('./case');\nexports.Text = require('./text');\nexports.Block = require('./block');\nexports.MixinBlock = require('./mixin-block');\nexports.Mixin = require('./mixin');\nexports.Filter = require('./filter');\nexports.Comment = require('./comment');\nexports.Literal = require('./literal');\nexports.BlockComment = require('./block-comment');\nexports.Doctype = require('./doctype');\n","\n\nvar Node = module.exports = function Node(){};\n\n/**\n * Clone this node (return itself)\n *\n * @return {Node}\n * @api private\n */\n\nNode.prototype.clone = function(){\n  var err = new Error('node.clone is deprecated and will be removed in v2.0.0');\n  console.warn(err.stack);\n  return this;\n};\n\nNode.prototype.type = '';\n","\n\nvar Attrs = require('./attrs');\nvar Block = require('./block');\nvar inlineTags = require('../inline-tags');\n\n/**\n * Initialize a `Tag` node with the given tag `name` and optional `block`.\n *\n * @param {String} name\n * @param {Block} block\n * @api public\n */\n\nvar Tag = module.exports = function Tag(name, block) {\n  Attrs.call(this);\n  this.name = name;\n  this.block = block || new Block;\n};\n\n// Inherit from `Attrs`.\nTag.prototype = Object.create(Attrs.prototype);\nTag.prototype.constructor = Tag;\n\nTag.prototype.type = 'Tag';\n\n/**\n * Clone this tag.\n *\n * @return {Tag}\n * @api private\n */\n\nTag.prototype.clone = function(){\n  var err = new Error('tag.clone is deprecated and will be removed in v2.0.0');\n  console.warn(err.stack);\n\n  var clone = new Tag(this.name, this.block.clone());\n  clone.line = this.line;\n  clone.attrs = this.attrs;\n  clone.textOnly = this.textOnly;\n  return clone;\n};\n\n/**\n * Check if this tag is an inline tag.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.isInline = function(){\n  return ~inlineTags.indexOf(this.name);\n};\n\n/**\n * Check if this tag's contents can be inlined.  Used for pretty printing.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.canInline = function(){\n  var nodes = this.block.nodes;\n\n  function isInline(node){\n    // Recurse if the node is a block\n    if (node.isBlock) return node.nodes.every(isInline);\n    return node.isText || (node.isInline && node.isInline());\n  }\n\n  // Empty tag\n  if (!nodes.length) return true;\n\n  // Text-only or inline-only tag\n  if (1 == nodes.length) return isInline(nodes[0]);\n\n  // Multi-line inline-only tag\n  if (this.block.nodes.every(isInline)) {\n    for (var i = 1, len = nodes.length; i < len; ++i) {\n      if (nodes[i-1].isText && nodes[i].isText)\n        return false;\n    }\n    return true;\n  }\n\n  // Mixed tag\n  return false;\n};\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Attrs` node.\n *\n * @api public\n */\n\nvar Attrs = module.exports = function Attrs() {\n  this.attributeNames = [];\n  this.attrs = [];\n  this.attributeBlocks = [];\n};\n\n// Inherit from `Node`.\nAttrs.prototype = Object.create(Node.prototype);\nAttrs.prototype.constructor = Attrs;\n\nAttrs.prototype.type = 'Attrs';\n\n/**\n * Set attribute `name` to `val`, keep in mind these become\n * part of a raw js object literal, so to quote a value you must\n * '\"quote me\"', otherwise or example 'user.name' is literal JavaScript.\n *\n * @param {String} name\n * @param {String} val\n * @param {Boolean} escaped\n * @return {Tag} for chaining\n * @api public\n */\n\nAttrs.prototype.setAttribute = function(name, val, escaped){\n  if (name !== 'class' && this.attributeNames.indexOf(name) !== -1) {\n    throw new Error('Duplicate attribute \"' + name + '\" is not allowed.');\n  }\n  this.attributeNames.push(name);\n  this.attrs.push({ name: name, val: val, escaped: escaped });\n  return this;\n};\n\n/**\n * Remove attribute `name` when present.\n *\n * @param {String} name\n * @api public\n */\n\nAttrs.prototype.removeAttribute = function(name){\n  var err = new Error('attrs.removeAttribute is deprecated and will be removed in v2.0.0');\n  console.warn(err.stack);\n\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      delete this.attrs[i];\n    }\n  }\n};\n\n/**\n * Get attribute value by `name`.\n *\n * @param {String} name\n * @return {String}\n * @api public\n */\n\nAttrs.prototype.getAttribute = function(name){\n  var err = new Error('attrs.getAttribute is deprecated and will be removed in v2.0.0');\n  console.warn(err.stack);\n\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      return this.attrs[i].val;\n    }\n  }\n};\n\nAttrs.prototype.addAttributes = function (src) {\n  this.attributeBlocks.push(src);\n};\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Block` with an optional `node`.\n *\n * @param {Node} node\n * @api public\n */\n\nvar Block = module.exports = function Block(node){\n  this.nodes = [];\n  if (node) this.push(node);\n};\n\n// Inherit from `Node`.\nBlock.prototype = Object.create(Node.prototype);\nBlock.prototype.constructor = Block;\n\nBlock.prototype.type = 'Block';\n\n/**\n * Block flag.\n */\n\nBlock.prototype.isBlock = true;\n\n/**\n * Replace the nodes in `other` with the nodes\n * in `this` block.\n *\n * @param {Block} other\n * @api private\n */\n\nBlock.prototype.replace = function(other){\n  var err = new Error('block.replace is deprecated and will be removed in v2.0.0');\n  console.warn(err.stack);\n\n  other.nodes = this.nodes;\n};\n\n/**\n * Push the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.push = function(node){\n  return this.nodes.push(node);\n};\n\n/**\n * Check if this block is empty.\n *\n * @return {Boolean}\n * @api public\n */\n\nBlock.prototype.isEmpty = function(){\n  return 0 == this.nodes.length;\n};\n\n/**\n * Unshift the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.unshift = function(node){\n  return this.nodes.unshift(node);\n};\n\n/**\n * Return the \"last\" block, or the first `yield` node.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.includeBlock = function(){\n  var ret = this\n    , node;\n\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    node = this.nodes[i];\n    if (node.yield) return node;\n    else if (node.textOnly) continue;\n    else if (node.includeBlock) ret = node.includeBlock();\n    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();\n    if (ret.yield) return ret;\n  }\n\n  return ret;\n};\n\n/**\n * Return a clone of this block.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.clone = function(){\n  var err = new Error('block.clone is deprecated and will be removed in v2.0.0');\n  console.warn(err.stack);\n\n  var clone = new Block;\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    clone.push(this.nodes[i].clone());\n  }\n  return clone;\n};\n","\n\nmodule.exports = [\n    'a'\n  , 'abbr'\n  , 'acronym'\n  , 'b'\n  , 'br'\n  , 'code'\n  , 'em'\n  , 'font'\n  , 'i'\n  , 'img'\n  , 'ins'\n  , 'kbd'\n  , 'map'\n  , 'samp'\n  , 'small'\n  , 'span'\n  , 'strong'\n  , 'sub'\n  , 'sup'\n];","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Code` node with the given code `val`.\n * Code may also be optionally buffered and escaped.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @param {Boolean} escape\n * @api public\n */\n\nvar Code = module.exports = function Code(val, buffer, escape) {\n  this.val = val;\n  this.buffer = buffer;\n  this.escape = escape;\n  if (val.match(/^ *else/)) this.debug = false;\n};\n\n// Inherit from `Node`.\nCode.prototype = Object.create(Node.prototype);\nCode.prototype.constructor = Code;\n\nCode.prototype.type = 'Code'; // prevent the minifiers removing this","\n\nvar Node = require('./node');\n\n/**\n * Initialize an `Each` node, representing iteration\n *\n * @param {String} obj\n * @param {String} val\n * @param {String} key\n * @param {Block} block\n * @api public\n */\n\nvar Each = module.exports = function Each(obj, val, key, block) {\n  this.obj = obj;\n  this.val = val;\n  this.key = key;\n  this.block = block;\n};\n\n// Inherit from `Node`.\nEach.prototype = Object.create(Node.prototype);\nEach.prototype.constructor = Each;\n\nEach.prototype.type = 'Each';\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Case` with `expr`.\n *\n * @param {String} expr\n * @api public\n */\n\nvar Case = exports = module.exports = function Case(expr, block){\n  this.expr = expr;\n  this.block = block;\n};\n\n// Inherit from `Node`.\nCase.prototype = Object.create(Node.prototype);\nCase.prototype.constructor = Case;\n\nCase.prototype.type = 'Case';\n\nvar When = exports.When = function When(expr, block){\n  this.expr = expr;\n  this.block = block;\n  this.debug = false;\n};\n\n// Inherit from `Node`.\nWhen.prototype = Object.create(Node.prototype);\nWhen.prototype.constructor = When;\n\nWhen.prototype.type = 'When';\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Text` node with optional `line`.\n *\n * @param {String} line\n * @api public\n */\n\nvar Text = module.exports = function Text(line) {\n  this.val = line;\n};\n\n// Inherit from `Node`.\nText.prototype = Object.create(Node.prototype);\nText.prototype.constructor = Text;\n\nText.prototype.type = 'Text';\n\n/**\n * Flag as text.\n */\n\nText.prototype.isText = true;","\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Block` with an optional `node`.\n *\n * @param {Node} node\n * @api public\n */\n\nvar MixinBlock = module.exports = function MixinBlock(){};\n\n// Inherit from `Node`.\nMixinBlock.prototype = Object.create(Node.prototype);\nMixinBlock.prototype.constructor = MixinBlock;\n\nMixinBlock.prototype.type = 'MixinBlock';\n","\n\nvar Attrs = require('./attrs');\n\n/**\n * Initialize a new `Mixin` with `name` and `block`.\n *\n * @param {String} name\n * @param {String} args\n * @param {Block} block\n * @api public\n */\n\nvar Mixin = module.exports = function Mixin(name, args, block, call){\n  Attrs.call(this);\n  this.name = name;\n  this.args = args;\n  this.block = block;\n  this.call = call;\n};\n\n// Inherit from `Attrs`.\nMixin.prototype = Object.create(Attrs.prototype);\nMixin.prototype.constructor = Mixin;\n\nMixin.prototype.type = 'Mixin';\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Filter` node with the given\n * filter `name` and `block`.\n *\n * @param {String} name\n * @param {Block|Node} block\n * @api public\n */\n\nvar Filter = module.exports = function Filter(name, block, attrs) {\n  this.name = name;\n  this.block = block;\n  this.attrs = attrs;\n};\n\n// Inherit from `Node`.\nFilter.prototype = Object.create(Node.prototype);\nFilter.prototype.constructor = Filter;\n\nFilter.prototype.type = 'Filter';\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Comment` with the given `val`, optionally `buffer`,\n * otherwise the comment may render in the output.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @api public\n */\n\nvar Comment = module.exports = function Comment(val, buffer) {\n  this.val = val;\n  this.buffer = buffer;\n};\n\n// Inherit from `Node`.\nComment.prototype = Object.create(Node.prototype);\nComment.prototype.constructor = Comment;\n\nComment.prototype.type = 'Comment';\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Literal` node with the given `str.\n *\n * @param {String} str\n * @api public\n */\n\nvar Literal = module.exports = function Literal(str) {\n  this.str = str;\n};\n\n// Inherit from `Node`.\nLiteral.prototype = Object.create(Node.prototype);\nLiteral.prototype.constructor = Literal;\n\nLiteral.prototype.type = 'Literal';\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `BlockComment` with the given `block`.\n *\n * @param {String} val\n * @param {Block} block\n * @param {Boolean} buffer\n * @api public\n */\n\nvar BlockComment = module.exports = function BlockComment(val, block, buffer) {\n  this.block = block;\n  this.val = val;\n  this.buffer = buffer;\n};\n\n// Inherit from `Node`.\nBlockComment.prototype = Object.create(Node.prototype);\nBlockComment.prototype.constructor = BlockComment;\n\nBlockComment.prototype.type = 'BlockComment';\n","\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Doctype` with the given `val`. \n *\n * @param {String} val\n * @api public\n */\n\nvar Doctype = module.exports = function Doctype(val) {\n  this.val = val;\n};\n\n// Inherit from `Node`.\nDoctype.prototype = Object.create(Node.prototype);\nDoctype.prototype.constructor = Doctype;\n\nDoctype.prototype.type = 'Doctype';\n","\n\nvar transformers = require('transformers');\nvar jstransformer = require('jstransformer');\nvar uglify = require('uglify-js');\nvar CleanCSS = require('clean-css');\n\nvar warned = {};\nvar alternatives = {\n  uglifyJS: 'uglify-js',\n  uglify: 'uglify-js',\n  uglifyCSS: 'clean-css',\n  'uglify-css': 'clean-css' ,\n  uglifyJSON: 'json',\n  'uglify-json': 'json',\n  live: 'livescript',\n  LiveScript: 'livescript',\n  ls: 'livescript',\n  // TODO: remove if we add support for coffeekup\n  coffeekup: 'coffeecup',\n  // The `style` transformer is not the same as the `stylus` jstransformer\n  styl: 'stylus',\n  coffee: 'coffee-script',\n  coffeescript: 'coffee-script',\n  coffeeScript: 'coffee-script',\n  // these marker transformers haven't made sense in a long time\n  css: 'verbatim',\n  js: 'verbatim',\n};\nvar deprecated = ['jqtpl', 'jazz'];\nfunction getMarkdownImplementation() {\n  var implementations = ['marked', 'supermarked', 'markdown-js', 'markdown'];\n  while (implementations.length) {\n    try {\n      require(implementations[0]);\n      return implementations[0];\n    } catch (ex) {\n      implementations.shift();\n    }\n  }\n  return 'markdown-it';\n}\n\nmodule.exports = filter;\nfunction filter(name, str, options) {\n  if (typeof filter[name] === 'function') {\n    return filter[name](str, options);\n  } else {\n    var tr;\n    try {\n      tr = jstransformer(require('jstransformer-' + name));\n    } catch (ex) {}\n    if (tr) {\n      // TODO: we may want to add a way for people to separately specify \"locals\"\n      var result = tr.render(str, options, options).body;\n      if (options && options.minify) {\n        try {\n          switch (tr.outputFormat) {\n            case 'js':\n              result = uglify.minify(result, {fromString: true}).code;\n              break;\n            case 'css':\n              result = new CleanCSS().minify(result).styles;\n              break;\n          }\n        } catch (ex) {\n          // better to fail to minify than output nothing\n        }\n      }\n      return result;\n    } else if (transformers[name]) {\n      if (!warned[name]) {\n        warned[name] = true;\n        if (name === 'md' || name === 'markdown') {\n          var implementation = getMarkdownImplementation();\n          console.log('Transformers.' + name + ' is deprecated, you must replace the :' +\n                      name + ' jade filter, with :' +\n                      implementation + ' and install jstransformer-' +\n                      implementation + ' before you update to jade@2.0.0.');\n        } else if (alternatives[name]) {\n          console.log('Transformers.' + name + ' is deprecated, you must replace the :' +\n                      name + ' jade filter, with :' +\n                      alternatives[name] + ' and install jstransformer-' +\n                      alternatives[name] + ' before you update to jade@2.0.0.');\n        } else {\n          console.log('Transformers.' + name + ' is deprecated, to continue using the :' +\n                      name + ' jade filter after jade@2.0.0, you will need to install jstransformer-' +\n                      name.toLowerCase() + '.');\n        }\n      }\n      return transformers[name].renderSync(str, options);\n    } else {\n      throw new Error('unknown filter \":' + name + '\"');\n    }\n  }\n}\n","\n\nvar nodes = require('./nodes');\nvar filters = require('./filters');\nvar doctypes = require('./doctypes');\nvar runtime = require('./runtime');\nvar utils = require('./utils');\nvar selfClosing = require('void-elements');\nvar parseJSExpression = require('character-parser').parseMax;\nvar constantinople = require('constantinople');\n\nfunction isConstant(src) {\n  return constantinople(src, {jade: runtime, 'jade_interp': undefined});\n}\nfunction toConstant(src) {\n  return constantinople.toConstant(src, {jade: runtime, 'jade_interp': undefined});\n}\nfunction errorAtNode(node, error) {\n  error.line = node.line;\n  error.filename = node.filename;\n  return error;\n}\n\n/**\n * Initialize `Compiler` with the given `node`.\n *\n * @param {Node} node\n * @param {Object} options\n * @api public\n */\n\nvar Compiler = module.exports = function Compiler(node, options) {\n  this.options = options = options || {};\n  this.node = node;\n  this.hasCompiledDoctype = false;\n  this.hasCompiledTag = false;\n  this.pp = options.pretty || false;\n  if (this.pp && typeof this.pp !== 'string') {\n    this.pp = '  ';\n  }\n  this.debug = false !== options.compileDebug;\n  this.indents = 0;\n  this.parentIndents = 0;\n  this.terse = false;\n  this.mixins = {};\n  this.dynamicMixins = false;\n  if (options.doctype) this.setDoctype(options.doctype);\n};\n\n/**\n * Compiler prototype.\n */\n\nCompiler.prototype = {\n\n  /**\n   * Compile parse tree to JavaScript.\n   *\n   * @api public\n   */\n\n  compile: function(){\n    this.buf = [];\n    if (this.pp) this.buf.push(\"var jade_indent = [];\");\n    this.lastBufferedIdx = -1;\n    this.visit(this.node);\n    if (!this.dynamicMixins) {\n      // if there are no dynamic mixins we can remove any un-used mixins\n      var mixinNames = Object.keys(this.mixins);\n      for (var i = 0; i < mixinNames.length; i++) {\n        var mixin = this.mixins[mixinNames[i]];\n        if (!mixin.used) {\n          for (var x = 0; x < mixin.instances.length; x++) {\n            for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++) {\n              this.buf[y] = '';\n            }\n          }\n        }\n      }\n    }\n    return this.buf.join('\\n');\n  },\n\n  /**\n   * Sets the default doctype `name`. Sets terse mode to `true` when\n   * html 5 is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {string} name\n   * @api public\n   */\n\n  setDoctype: function(name){\n    this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';\n    this.terse = this.doctype.toLowerCase() == '<!doctype html>';\n    this.xml = 0 == this.doctype.indexOf('<?xml');\n  },\n\n  /**\n   * Buffer the given `str` exactly as is or with interpolation\n   *\n   * @param {String} str\n   * @param {Boolean} interpolate\n   * @api public\n   */\n\n  buffer: function (str, interpolate) {\n    var self = this;\n    if (interpolate) {\n      var match = /(\\\\)?([#!]){((?:.|\\n)*)$/.exec(str);\n      if (match) {\n        this.buffer(str.substr(0, match.index), false);\n        if (match[1]) { // escape\n          this.buffer(match[2] + '{', false);\n          this.buffer(match[3], true);\n          return;\n        } else {\n          var rest = match[3];\n          var range = parseJSExpression(rest);\n          var code = ('!' == match[2] ? '' : 'jade.escape') + \"((jade_interp = \" + range.src + \") == null ? '' : jade_interp)\";\n          this.bufferExpression(code);\n          this.buffer(rest.substr(range.end + 1), true);\n          return;\n        }\n      }\n    }\n\n    str = utils.stringify(str);\n    str = str.substr(1, str.length - 2);\n\n    if (this.lastBufferedIdx == this.buf.length) {\n      if (this.lastBufferedType === 'code') this.lastBuffered += ' + \"';\n      this.lastBufferedType = 'text';\n      this.lastBuffered += str;\n      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '\");'\n    } else {\n      this.buf.push('buf.push(\"' + str + '\");');\n      this.lastBufferedType = 'text';\n      this.bufferStartChar = '\"';\n      this.lastBuffered = str;\n      this.lastBufferedIdx = this.buf.length;\n    }\n  },\n\n  /**\n   * Buffer the given `src` so it is evaluated at run time\n   *\n   * @param {String} src\n   * @api public\n   */\n\n  bufferExpression: function (src) {\n    if (isConstant(src)) {\n      return this.buffer(toConstant(src) + '', false)\n    }\n    if (this.lastBufferedIdx == this.buf.length) {\n      if (this.lastBufferedType === 'text') this.lastBuffered += '\"';\n      this.lastBufferedType = 'code';\n      this.lastBuffered += ' + (' + src + ')';\n      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'\n    } else {\n      this.buf.push('buf.push(' + src + ');');\n      this.lastBufferedType = 'code';\n      this.bufferStartChar = '';\n      this.lastBuffered = '(' + src + ')';\n      this.lastBufferedIdx = this.buf.length;\n    }\n  },\n\n  /**\n   * Buffer an indent based on the current `indent`\n   * property and an additional `offset`.\n   *\n   * @param {Number} offset\n   * @param {Boolean} newline\n   * @api public\n   */\n\n  prettyIndent: function(offset, newline){\n    offset = offset || 0;\n    newline = newline ? '\\n' : '';\n    this.buffer(newline + Array(this.indents + offset).join(this.pp));\n    if (this.parentIndents)\n      this.buf.push(\"buf.push.apply(buf, jade_indent);\");\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visit: function(node){\n    var debug = this.debug;\n\n    if (debug) {\n      this.buf.push('jade_debug.unshift(new jade.DebugItem( ' + node.line\n        + ', ' + (node.filename\n          ? utils.stringify(node.filename)\n          : 'jade_debug[0].filename')\n        + ' ));');\n    }\n\n    // Massive hack to fix our context\n    // stack for - else[ if] etc\n    if (false === node.debug && this.debug) {\n      this.buf.pop();\n      this.buf.pop();\n    }\n\n    this.visitNode(node);\n\n    if (debug) this.buf.push('jade_debug.shift();');\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visitNode: function(node){\n    return this['visit' + node.type](node);\n  },\n\n  /**\n   * Visit case `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitCase: function(node){\n    var _ = this.withinCase;\n    this.withinCase = true;\n    this.buf.push('switch (' + node.expr + '){');\n    this.visit(node.block);\n    this.buf.push('}');\n    this.withinCase = _;\n  },\n\n  /**\n   * Visit when `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitWhen: function(node){\n    if ('default' == node.expr) {\n      this.buf.push('default:');\n    } else {\n      this.buf.push('case ' + node.expr + ':');\n    }\n    if (node.block) {\n      this.visit(node.block);\n      this.buf.push('  break;');\n    }\n  },\n\n  /**\n   * Visit literal `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitLiteral: function(node){\n    this.buffer(node.str);\n  },\n\n  /**\n   * Visit all nodes in `block`.\n   *\n   * @param {Block} block\n   * @api public\n   */\n\n  visitBlock: function(block){\n    var len = block.nodes.length\n      , escape = this.escape\n      , pp = this.pp\n\n    // Pretty print multi-line text\n    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)\n      this.prettyIndent(1, true);\n\n    for (var i = 0; i < len; ++i) {\n      // Pretty print text\n      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)\n        this.prettyIndent(1, false);\n\n      this.visit(block.nodes[i]);\n      // Multiple text nodes are separated by newlines\n      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)\n        this.buffer('\\n');\n    }\n  },\n\n  /**\n   * Visit a mixin's `block` keyword.\n   *\n   * @param {MixinBlock} block\n   * @api public\n   */\n\n  visitMixinBlock: function(block){\n    if (this.pp) this.buf.push(\"jade_indent.push('\" + Array(this.indents + 1).join(this.pp) + \"');\");\n    this.buf.push('block && block();');\n    if (this.pp) this.buf.push(\"jade_indent.pop();\");\n  },\n\n  /**\n   * Visit `doctype`. Sets terse mode to `true` when html 5\n   * is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {Doctype} doctype\n   * @api public\n   */\n\n  visitDoctype: function(doctype){\n    if (doctype && (doctype.val || !this.doctype)) {\n      this.setDoctype(doctype.val || 'default');\n    }\n\n    if (this.doctype) this.buffer(this.doctype);\n    this.hasCompiledDoctype = true;\n  },\n\n  /**\n   * Visit `mixin`, generating a function that\n   * may be called within the template.\n   *\n   * @param {Mixin} mixin\n   * @api public\n   */\n\n  visitMixin: function(mixin){\n    var name = 'jade_mixins[';\n    var args = mixin.args || '';\n    var block = mixin.block;\n    var attrs = mixin.attrs;\n    var attrsBlocks = mixin.attributeBlocks.slice();\n    var pp = this.pp;\n    var dynamic = mixin.name[0]==='#';\n    var key = mixin.name;\n    if (dynamic) this.dynamicMixins = true;\n    name += (dynamic ? mixin.name.substr(2,mixin.name.length-3):'\"'+mixin.name+'\"')+']';\n\n    this.mixins[key] = this.mixins[key] || {used: false, instances: []};\n    if (mixin.call) {\n      this.mixins[key].used = true;\n      if (pp) this.buf.push(\"jade_indent.push('\" + Array(this.indents + 1).join(pp) + \"');\")\n      if (block || attrs.length || attrsBlocks.length) {\n\n        this.buf.push(name + '.call({');\n\n        if (block) {\n          this.buf.push('block: function(){');\n\n          // Render block with no indents, dynamically added when rendered\n          this.parentIndents++;\n          var _indents = this.indents;\n          this.indents = 0;\n          this.visit(mixin.block);\n          this.indents = _indents;\n          this.parentIndents--;\n\n          if (attrs.length || attrsBlocks.length) {\n            this.buf.push('},');\n          } else {\n            this.buf.push('}');\n          }\n        }\n\n        if (attrsBlocks.length) {\n          if (attrs.length) {\n            var val = this.attrs(attrs);\n            attrsBlocks.unshift(val);\n          }\n          this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');\n        } else if (attrs.length) {\n          var val = this.attrs(attrs);\n          this.buf.push('attributes: ' + val);\n        }\n\n        if (args) {\n          this.buf.push('}, ' + args + ');');\n        } else {\n          this.buf.push('});');\n        }\n\n      } else {\n        this.buf.push(name + '(' + args + ');');\n      }\n      if (pp) this.buf.push(\"jade_indent.pop();\")\n    } else {\n      var mixin_start = this.buf.length;\n      args = args ? args.split(',') : [];\n      var rest;\n      if (args.length && /^\\.\\.\\./.test(args[args.length - 1].trim())) {\n        rest = args.pop().trim().replace(/^\\.\\.\\./, '');\n      }\n      // we need use jade_interp here for v8: https://code.google.com/p/v8/issues/detail?id=4165\n      // once fixed, use this: this.buf.push(name + ' = function(' + args.join(',') + '){');\n      this.buf.push(name + ' = jade_interp = function(' + args.join(',') + '){');\n      this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');\n      if (rest) {\n        this.buf.push('var ' + rest + ' = [];');\n        this.buf.push('for (jade_interp = ' + args.length + '; jade_interp < arguments.length; jade_interp++) {');\n        this.buf.push('  ' + rest + '.push(arguments[jade_interp]);');\n        this.buf.push('}');\n      }\n      this.parentIndents++;\n      this.visit(block);\n      this.parentIndents--;\n      this.buf.push('};');\n      var mixin_end = this.buf.length;\n      this.mixins[key].instances.push({start: mixin_start, end: mixin_end});\n    }\n  },\n\n  /**\n   * Visit `tag` buffering tag markup, generating\n   * attributes, visiting the `tag`'s code and block.\n   *\n   * @param {Tag} tag\n   * @api public\n   */\n\n  visitTag: function(tag){\n    this.indents++;\n    var name = tag.name\n      , pp = this.pp\n      , self = this;\n\n    function bufferName() {\n      if (tag.buffer) self.bufferExpression(name);\n      else self.buffer(name);\n    }\n\n    if ('pre' == tag.name) this.escape = true;\n\n    if (!this.hasCompiledTag) {\n      if (!this.hasCompiledDoctype && 'html' == name) {\n        this.visitDoctype();\n      }\n      this.hasCompiledTag = true;\n    }\n\n    // pretty print\n    if (pp && !tag.isInline())\n      this.prettyIndent(0, true);\n\n    if (tag.selfClosing || (!this.xml && selfClosing[tag.name])) {\n      this.buffer('<');\n      bufferName();\n      this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());\n      this.terse\n        ? this.buffer('>')\n        : this.buffer('/>');\n      // if it is non-empty throw an error\n      if (tag.block &&\n          !(tag.block.type === 'Block' && tag.block.nodes.length === 0) &&\n          tag.block.nodes.some(function (tag) {\n            return tag.type !== 'Text' || !/^\\s*$/.test(tag.val)\n          })) {\n        throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));\n      }\n    } else {\n      // Optimize attributes buffering\n      this.buffer('<');\n      bufferName();\n      this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());\n      this.buffer('>');\n      if (tag.code) this.visitCode(tag.code);\n      this.visit(tag.block);\n\n      // pretty print\n      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())\n        this.prettyIndent(0, true);\n\n      this.buffer('</');\n      bufferName();\n      this.buffer('>');\n    }\n\n    if ('pre' == tag.name) this.escape = false;\n\n    this.indents--;\n  },\n\n  /**\n   * Visit `filter`, throwing when the filter does not exist.\n   *\n   * @param {Filter} filter\n   * @api public\n   */\n\n  visitFilter: function(filter){\n    var text = filter.block.nodes.map(\n      function(node){ return node.val; }\n    ).join('\\n');\n    filter.attrs.filename = this.options.filename;\n    try {\n      this.buffer(filters(filter.name, text, filter.attrs), true);\n    } catch (err) {\n      throw errorAtNode(filter, err);\n    }\n  },\n\n  /**\n   * Visit `text` node.\n   *\n   * @param {Text} text\n   * @api public\n   */\n\n  visitText: function(text){\n    this.buffer(text.val, true);\n  },\n\n  /**\n   * Visit a `comment`, only buffering when the buffer flag is set.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitComment: function(comment){\n    if (!comment.buffer) return;\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('<!--' + comment.val + '-->');\n  },\n\n  /**\n   * Visit a `BlockComment`.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitBlockComment: function(comment){\n    if (!comment.buffer) return;\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('<!--' + comment.val);\n    this.visit(comment.block);\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('-->');\n  },\n\n  /**\n   * Visit `code`, respecting buffer / escape flags.\n   * If the code is followed by a block, wrap it in\n   * a self-calling function.\n   *\n   * @param {Code} code\n   * @api public\n   */\n\n  visitCode: function(code){\n    // Wrap code blocks with {}.\n    // we only wrap unbuffered code blocks ATM\n    // since they are usually flow control\n\n    // Buffer code\n    if (code.buffer) {\n      var val = code.val.trim();\n      val = 'null == (jade_interp = '+val+') ? \"\" : jade_interp';\n      if (code.escape) val = 'jade.escape(' + val + ')';\n      this.bufferExpression(val);\n    } else {\n      this.buf.push(code.val);\n    }\n\n    // Block support\n    if (code.block) {\n      if (!code.buffer) this.buf.push('{');\n      this.visit(code.block);\n      if (!code.buffer) this.buf.push('}');\n    }\n  },\n\n  /**\n   * Visit `each` block.\n   *\n   * @param {Each} each\n   * @api public\n   */\n\n  visitEach: function(each){\n    this.buf.push(''\n      + '// iterate ' + each.obj + '\\n'\n      + ';(function(){\\n'\n      + '  var $$obj = ' + each.obj + ';\\n'\n      + '  if (\\'number\\' == typeof $$obj.length) {\\n');\n\n    if (each.alternative) {\n      this.buf.push('  if ($$obj.length) {');\n    }\n\n    this.buf.push(''\n      + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\\n'\n      + '      var ' + each.val + ' = $$obj[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n    this.buf.push('    }\\n');\n\n    if (each.alternative) {\n      this.buf.push('  } else {');\n      this.visit(each.alternative);\n      this.buf.push('  }');\n    }\n\n    this.buf.push(''\n      + '  } else {\\n'\n      + '    var $$l = 0;\\n'\n      + '    for (var ' + each.key + ' in $$obj) {\\n'\n      + '      $$l++;'\n      + '      var ' + each.val + ' = $$obj[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n    this.buf.push('    }\\n');\n    if (each.alternative) {\n      this.buf.push('    if ($$l === 0) {');\n      this.visit(each.alternative);\n      this.buf.push('    }');\n    }\n    this.buf.push('  }\\n}).call(this);\\n');\n  },\n\n  /**\n   * Visit `attrs`.\n   *\n   * @param {Array} attrs\n   * @api public\n   */\n\n  visitAttributes: function(attrs, attributeBlocks){\n    if (attributeBlocks.length) {\n      if (attrs.length) {\n        var val = this.attrs(attrs);\n        attributeBlocks.unshift(val);\n      }\n      this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(',') + ']), ' + utils.stringify(this.terse) + ')');\n    } else if (attrs.length) {\n      this.attrs(attrs, true);\n    }\n  },\n\n  /**\n   * Compile attributes.\n   */\n\n  attrs: function(attrs, buffer){\n    var buf = [];\n    var classes = [];\n    var classEscaping = [];\n\n    attrs.forEach(function(attr){\n      var key = attr.name;\n      var escaped = attr.escaped;\n\n      if (key === 'class') {\n        classes.push(attr.val);\n        classEscaping.push(attr.escaped);\n      } else if (isConstant(attr.val)) {\n        if (buffer) {\n          this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));\n        } else {\n          var val = toConstant(attr.val);\n          if (key === 'style') val = runtime.style(val);\n          if (escaped && !(key.indexOf('data') === 0 && typeof val !== 'string')) {\n            val = runtime.escape(val);\n          }\n          buf.push(utils.stringify(key) + ': ' + utils.stringify(val));\n        }\n      } else {\n        if (buffer) {\n          this.bufferExpression('jade.attr(\"' + key + '\", ' + attr.val + ', ' + utils.stringify(escaped) + ', ' + utils.stringify(this.terse) + ')');\n        } else {\n          var val = attr.val;\n          if (key === 'style') {\n            val = 'jade.style(' + val + ')';\n          }\n          if (escaped && !(key.indexOf('data') === 0)) {\n            val = 'jade.escape(' + val + ')';\n          } else if (escaped) {\n            val = '(typeof (jade_interp = ' + val + ') == \"string\" ? jade.escape(jade_interp) : jade_interp)';\n          }\n          buf.push(utils.stringify(key) + ': ' + val);\n        }\n      }\n    }.bind(this));\n    if (buffer) {\n      if (classes.every(isConstant)) {\n        this.buffer(runtime.cls(classes.map(toConstant), classEscaping));\n      } else {\n        this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + utils.stringify(classEscaping) + ')');\n      }\n    } else if (classes.length) {\n      if (classes.every(isConstant)) {\n        classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {\n          return classEscaping[i] ? runtime.escape(cls) : cls;\n        })));\n      } else {\n        classes = '(jade_interp = ' + utils.stringify(classEscaping) + ',' +\n          ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {' +\n          '   return jade_interp[i] ? jade.escape(cls) : cls' +\n          ' }))' +\n          ')';\n      }\n      if (classes.length)\n        buf.push('\"class\": ' + classes);\n    }\n    return '{' + buf.join(',') + '}';\n  }\n};\n","\n\nmodule.exports = {\n    'default': '<!DOCTYPE html>'\n  , 'xml': '<?xml version=\"1.0\" encoding=\"utf-8\" ?>'\n  , 'transitional': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">'\n  , 'strict': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">'\n  , 'frameset': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">'\n  , '1.1': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">'\n  , 'basic': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">'\n  , 'mobile': '<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">'\n};","\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    a['class'] = ac.concat(bc).filter(nulls);\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {*} val\n * @return {Boolean}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null && val !== '';\n}\n\n/**\n * join array as classes.\n *\n * @param {*} val\n * @return {String}\n */\nexports.joinClasses = joinClasses;\nfunction joinClasses(val) {\n  return (Array.isArray(val) ? val.map(joinClasses) :\n    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :\n    [val]).filter(nulls).join(' ');\n}\n\n/**\n * Render the given classes.\n *\n * @param {Array} classes\n * @param {Array.<Boolean>} escaped\n * @return {String}\n */\nexports.cls = function cls(classes, escaped) {\n  var buf = [];\n  for (var i = 0; i < classes.length; i++) {\n    if (escaped && escaped[i]) {\n      buf.push(exports.escape(joinClasses([classes[i]])));\n    } else {\n      buf.push(joinClasses(classes[i]));\n    }\n  }\n  var text = joinClasses(buf);\n  if (text.length) {\n    return ' class=\"' + text + '\"';\n  } else {\n    return '';\n  }\n};\n\n\nexports.style = function (val) {\n  if (val && typeof val === 'object') {\n    return Object.keys(val).map(function (style) {\n      return style + ':' + val[style];\n    }).join(';');\n  } else {\n    return val;\n  }\n};\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = function attr(key, val, escaped, terse) {\n  if (key === 'style') {\n    val = exports.style(val);\n  }\n  if ('boolean' == typeof val || null == val) {\n    if (val) {\n      return ' ' + (terse ? key : key + '=\"' + key + '\"');\n    } else {\n      return '';\n    }\n  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n    if (JSON.stringify(val).indexOf('&') !== -1) {\n      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +\n                   'will be escaped to `&amp;`');\n    };\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will eliminate the double quotes around dates in ' +\n                   'ISO form after 2.0.0');\n    }\n    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\n  } else if (escaped) {\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n    }\n    return ' ' + key + '=\"' + exports.escape(val) + '\"';\n  } else {\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n    }\n    return ' ' + key + '=\"' + val + '\"';\n  }\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n */\nexports.attrs = function attrs(obj, terse){\n  var buf = [];\n\n  var keys = Object.keys(obj);\n\n  if (keys.length) {\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('class' == key) {\n        if (val = joinClasses(val)) {\n          buf.push(' ' + key + '=\"' + val + '\"');\n        }\n      } else {\n        buf.push(exports.attr(key, val, false, terse));\n      }\n    }\n  }\n\n  return buf.join('');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nvar jade_encode_html_rules = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\nvar jade_match_html = /[&<>\"]/g;\n\nfunction jade_encode_char(c) {\n  return jade_encode_html_rules[c] || c;\n}\n\nexports.escape = jade_escape;\nfunction jade_escape(html){\n  var result = String(html).replace(jade_match_html, jade_encode_char);\n  if (result === '' + html) return html;\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str = str || require('fs').readFileSync(filename, 'utf8')\n  } catch (ex) {\n    rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\nexports.DebugItem = function DebugItem(lineno, filename) {\n  this.lineno = lineno;\n  this.filename = filename;\n}\n"]}