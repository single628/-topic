{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["exports = (module.exports = parse);\r\nexports.parse = parse;\r\nfunction parse(src, state, options) {\r\n  options = options || {};\r\n  state = state || exports.defaultState();\r\n  var start = options.start || 0;\r\n  var end = options.end || src.length;\r\n  var index = start;\r\n  while (index < end) {\r\n    if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {\r\n      throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);\r\n    }\r\n    exports.parseChar(src[index++], state);\r\n  }\r\n  return state;\r\n}\r\n\r\nexports.parseMax = parseMax;\r\nfunction parseMax(src, options) {\r\n  options = options || {};\r\n  var start = options.start || 0;\r\n  var index = start;\r\n  var state = exports.defaultState();\r\n  while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {\r\n    if (index >= src.length) {\r\n      throw new Error('The end of the string was reached with no closing bracket found.');\r\n    }\r\n    exports.parseChar(src[index++], state);\r\n  }\r\n  var end = index - 1;\r\n  return {\r\n    start: start,\r\n    end: end,\r\n    src: src.substring(start, end)\r\n  };\r\n}\r\n\r\nexports.parseUntil = parseUntil;\r\nfunction parseUntil(src, delimiter, options) {\r\n  options = options || {};\r\n  var includeLineComment = options.includeLineComment || false;\r\n  var start = options.start || 0;\r\n  var index = start;\r\n  var state = exports.defaultState();\r\n  while (state.isString() || state.regexp || state.blockComment ||\r\n         (!includeLineComment && state.lineComment) || !startsWith(src, delimiter, index)) {\r\n    exports.parseChar(src[index++], state);\r\n  }\r\n  var end = index;\r\n  return {\r\n    start: start,\r\n    end: end,\r\n    src: src.substring(start, end)\r\n  };\r\n}\r\n\r\n\r\nexports.parseChar = parseChar;\r\nfunction parseChar(character, state) {\r\n  if (character.length !== 1) throw new Error('Character must be a string of length 1');\r\n  state = state || exports.defaultState();\r\n  state.src = state.src || '';\r\n  state.src += character;\r\n  var wasComment = state.blockComment || state.lineComment;\r\n  var lastChar = state.history ? state.history[0] : '';\r\n\r\n  if (state.regexpStart) {\r\n    if (character === '/' || character == '*') {\r\n      state.regexp = false;\r\n    }\r\n    state.regexpStart = false;\r\n  }\r\n  if (state.lineComment) {\r\n    if (character === '\\n') {\r\n      state.lineComment = false;\r\n    }\r\n  } else if (state.blockComment) {\r\n    if (state.lastChar === '*' && character === '/') {\r\n      state.blockComment = false;\r\n    }\r\n  } else if (state.singleQuote) {\r\n    if (character === '\\'' && !state.escaped) {\r\n      state.singleQuote = false;\r\n    } else if (character === '\\\\' && !state.escaped) {\r\n      state.escaped = true;\r\n    } else {\r\n      state.escaped = false;\r\n    }\r\n  } else if (state.doubleQuote) {\r\n    if (character === '\"' && !state.escaped) {\r\n      state.doubleQuote = false;\r\n    } else if (character === '\\\\' && !state.escaped) {\r\n      state.escaped = true;\r\n    } else {\r\n      state.escaped = false;\r\n    }\r\n  } else if (state.regexp) {\r\n    if (character === '/' && !state.escaped) {\r\n      state.regexp = false;\r\n    } else if (character === '\\\\' && !state.escaped) {\r\n      state.escaped = true;\r\n    } else {\r\n      state.escaped = false;\r\n    }\r\n  } else if (lastChar === '/' && character === '/') {\r\n    state.history = state.history.substr(1);\r\n    state.lineComment = true;\r\n  } else if (lastChar === '/' && character === '*') {\r\n    state.history = state.history.substr(1);\r\n    state.blockComment = true;\r\n  } else if (character === '/' && isRegexp(state.history)) {\r\n    state.regexp = true;\r\n    state.regexpStart = true;\r\n  } else if (character === '\\'') {\r\n    state.singleQuote = true;\r\n  } else if (character === '\"') {\r\n    state.doubleQuote = true;\r\n  } else if (character === '(') {\r\n    state.roundDepth++;\r\n  } else if (character === ')') {\r\n    state.roundDepth--;\r\n  } else if (character === '{') {\r\n    state.curlyDepth++;\r\n  } else if (character === '}') {\r\n    state.curlyDepth--;\r\n  } else if (character === '[') {\r\n    state.squareDepth++;\r\n  } else if (character === ']') {\r\n    state.squareDepth--;\r\n  }\r\n  if (!state.blockComment && !state.lineComment && !wasComment) state.history = character + state.history;\r\n  state.lastChar = character; // store last character for ending block comments\r\n  return state;\r\n}\r\n\r\nexports.defaultState = function () { return new State() };\r\nfunction State() {\r\n  this.lineComment = false;\r\n  this.blockComment = false;\r\n\r\n  this.singleQuote = false;\r\n  this.doubleQuote = false;\r\n  this.regexp = false;\r\n\r\n  this.escaped = false;\r\n\r\n  this.roundDepth = 0;\r\n  this.curlyDepth = 0;\r\n  this.squareDepth = 0;\r\n\r\n  this.history = ''\r\n  this.lastChar = ''\r\n}\r\nState.prototype.isString = function () {\r\n  return this.singleQuote || this.doubleQuote;\r\n}\r\nState.prototype.isComment = function () {\r\n  return this.lineComment || this.blockComment;\r\n}\r\nState.prototype.isNesting = function () {\r\n  return this.isString() || this.isComment() || this.regexp || this.roundDepth > 0 || this.curlyDepth > 0 || this.squareDepth > 0\r\n}\r\n\r\nfunction startsWith(str, start, i) {\r\n  return str.substr(i || 0, start.length) === start;\r\n}\r\n\r\nexports.isPunctuator = isPunctuator\r\nfunction isPunctuator(c) {\r\n  if (!c) return true; // the start of a string is a punctuator\r\n  var code = c.charCodeAt(0)\r\n\r\n  switch (code) {\r\n    case 46:   // . dot\r\n    case 40:   // ( open bracket\r\n    case 41:   // ) close bracket\r\n    case 59:   // ; semicolon\r\n    case 44:   // , comma\r\n    case 123:  // { open curly brace\r\n    case 125:  // } close curly brace\r\n    case 91:   // [\r\n    case 93:   // ]\r\n    case 58:   // :\r\n    case 63:   // ?\r\n    case 126:  // ~\r\n    case 37:   // %\r\n    case 38:   // &\r\n    case 42:   // *:\r\n    case 43:   // +\r\n    case 45:   // -\r\n    case 47:   // /\r\n    case 60:   // <\r\n    case 62:   // >\r\n    case 94:   // ^\r\n    case 124:  // |\r\n    case 33:   // !\r\n    case 61:   // =\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\nexports.isKeyword = isKeyword\r\nfunction isKeyword(id) {\r\n  return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||\r\n         (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||\r\n         (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||\r\n         (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||\r\n         (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||\r\n         (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||\r\n         (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||\r\n         (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static') ||\r\n         (id === 'yield') || (id === 'let');\r\n}\r\n\r\nfunction isRegexp(history) {\r\n  //could be start of regexp or divide sign\r\n\r\n  history = history.replace(/^\\s*/, '');\r\n\r\n  //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide\r\n  if (history[0] === ')') return false;\r\n  //unless it's a function expression, it's a regexp, so we assume it's a regexp\r\n  if (history[0] === '}') return true;\r\n  //any punctuation means it's a regexp\r\n  if (isPunctuator(history[0])) return true;\r\n  //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)\r\n  if (/^\\w+\\b/.test(history) && isKeyword(/^\\w+\\b/.exec(history)[0].split('').reverse().join(''))) return true;\r\n\r\n  return false;\r\n}\r\n"]}