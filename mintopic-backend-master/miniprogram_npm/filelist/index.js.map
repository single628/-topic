{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nvar fs = require('fs')\n, path = require('path')\n, minimatch = require('minimatch')\n, escapeRegExpChars\n, merge\n, basedir\n, _readDir\n, readdirR\n, globSync;\n\n  /**\n    @name escapeRegExpChars\n    @function\n    @return {String} A string of escaped characters\n    @description Escapes regex control-characters in strings\n                 used to build regexes dynamically\n    @param {String} string The string of chars to escape\n  */\n  escapeRegExpChars = (function () {\n    var specials = [ '^', '$', '/', '.', '*', '+', '?', '|', '(', ')',\n        '[', ']', '{', '}', '\\\\' ];\n    var sRE = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n    return function (string) {\n      var str = string || '';\n      str = String(str);\n      return str.replace(sRE, '\\\\$1');\n    };\n  })();\n\n  /**\n    @name merge\n    @function\n    @return {Object} Returns the merged object\n    @description Merge merges `otherObject` into `object` and takes care of deep\n                 merging of objects\n    @param {Object} object Object to merge into\n    @param {Object} otherObject Object to read from\n  */\n  merge = function (object, otherObject) {\n    var obj = object || {}\n      , otherObj = otherObject || {}\n      , key, value;\n\n    for (key in otherObj) {\n      value = otherObj[key];\n\n      // Check if a value is an Object, if so recursively add it's key/values\n      if (typeof value === 'object' && !(value instanceof Array)) {\n        // Update value of object to the one from otherObj\n        obj[key] = merge(obj[key], value);\n      }\n      // Value is anything other than an Object, so just add it\n      else {\n        obj[key] = value;\n      }\n    }\n\n    return obj;\n  };\n  /**\n    Given a patern, return the base directory of it (ie. the folder\n    that will contain all the files matching the path).\n    eg. file.basedir('/test/**') => '/test/'\n    Path ending by '/' are considerd as folder while other are considerd\n    as files, eg.:\n        file.basedir('/test/a/') => '/test/a'\n        file.basedir('/test/a') => '/test'\n    The returned path always end with a '/' so we have:\n        file.basedir(file.basedir(x)) == file.basedir(x)\n  */\n  basedir = function (pathParam) {\n    var bd = ''\n      , parts\n      , part\n      , pos = 0\n      , p = pathParam || '';\n\n    // If the path has a leading asterisk, basedir is the current dir\n    if (p.indexOf('*') == 0 || p.indexOf('**') == 0) {\n      return '.';\n    }\n\n    // always consider .. at the end as a folder and not a filename\n    if (/(?:^|\\/|\\\\)\\.\\.$/.test(p.slice(-3))) {\n      p += '/';\n    }\n\n    parts = p.split(/\\\\|\\//);\n    for (var i = 0, l = parts.length - 1; i < l; i++) {\n      part = parts[i];\n      if (part.indexOf('*') > -1 || part.indexOf('**') > -1) {\n        break;\n      }\n      pos += part.length + 1;\n      bd += part + p[pos - 1];\n    }\n    if (!bd) {\n      bd = '.';\n    }\n    // Strip trailing slashes\n    if (!(bd == '\\\\' || bd == '/')) {\n      bd = bd.replace(/\\\\$|\\/$/, '');\n    }\n    return bd;\n\n  };\n\n  // Return the contents of a given directory\n  _readDir = function (dirPath) {\n    var dir = path.normalize(dirPath)\n      , paths = []\n      , ret = [dir]\n      , msg;\n\n    try {\n      paths = fs.readdirSync(dir);\n    }\n    catch (e) {\n      msg = 'Could not read path ' + dir + '\\n';\n      if (e.stack) {\n        msg += e.stack;\n      }\n      throw new Error(msg);\n    }\n\n    paths.forEach(function (p) {\n      var curr = path.join(dir, p);\n      var stat = fs.statSync(curr);\n      if (stat.isDirectory()) {\n        ret = ret.concat(_readDir(curr));\n      }\n      else {\n        ret.push(curr);\n      }\n    });\n\n    return ret;\n  };\n\n  /**\n    @name file#readdirR\n    @function\n    @return {Array} Returns the contents as an Array, can be configured via opts.format\n    @description Reads the given directory returning it's contents\n    @param {String} dir The directory to read\n    @param {Object} opts Options to use\n      @param {String} [opts.format] Set the format to return(Default: Array)\n  */\n  readdirR = function (dir, opts) {\n    var options = opts || {}\n      , format = options.format || 'array'\n      , ret;\n    ret = _readDir(dir);\n    return format == 'string' ? ret.join('\\n') : ret;\n  };\n\n\nglobSync = function (pat, opts) {\n  var dirname = basedir(pat)\n    , files\n    , matches;\n\n  try {\n    files = readdirR(dirname).map(function(file){\n      return file.replace(/\\\\/g, '/');\n    });\n  }\n  // Bail if path doesn't exist -- assume no files\n  catch(e) {\n    if (FileList.verbose) console.error(e.message);\n  }\n\n  if (files) {\n    pat = path.normalize(pat);\n    matches = minimatch.match(files, pat, opts || {});\n  }\n  return matches || [];\n};\n\n// Constants\n// ---------------\n// List of all the builtin Array methods we want to override\nvar ARRAY_METHODS = Object.getOwnPropertyNames(Array.prototype)\n// Array methods that return a copy instead of affecting the original\n  , SPECIAL_RETURN = {\n      'concat': true\n    , 'slice': true\n    , 'filter': true\n    , 'map': true\n    }\n// Default file-patterns we want to ignore\n  , DEFAULT_IGNORE_PATTERNS = [\n      /(^|[\\/\\\\])CVS([\\/\\\\]|$)/\n    , /(^|[\\/\\\\])\\.svn([\\/\\\\]|$)/\n    , /(^|[\\/\\\\])\\.git([\\/\\\\]|$)/\n    , /\\.bak$/\n    , /~$/\n    ]\n// Ignore core files\n  , DEFAULT_IGNORE_FUNCS = [\n      function (name) {\n        var isDir = false\n          , stats;\n        try {\n          stats = fs.statSync(name);\n          isDir = stats.isDirectory();\n        }\n        catch(e) {}\n        return (/(^|[\\/\\\\])core$/).test(name) && !isDir;\n      }\n    ];\n\nvar FileList = function () {\n  var self = this\n    , wrap;\n\n  // List of glob-patterns or specific filenames\n  this.pendingAdd = [];\n  // Switched to false after lazy-eval of files\n  this.pending = true;\n  // Used to calculate exclusions from the list of files\n  this.excludes = {\n    pats: DEFAULT_IGNORE_PATTERNS.slice()\n  , funcs: DEFAULT_IGNORE_FUNCS.slice()\n  , regex: null\n  };\n  this.items = [];\n\n  // Wrap the array methods with the delegates\n  wrap = function (prop) {\n    var arr;\n    self[prop] = function () {\n      if (self.pending) {\n        self.resolve();\n      }\n      if (typeof self.items[prop] == 'function') {\n        // Special method that return a copy\n        if (SPECIAL_RETURN[prop]) {\n          arr = self.items[prop].apply(self.items, arguments);\n          return FileList.clone(self, arr);\n        }\n        else {\n          return self.items[prop].apply(self.items, arguments);\n        }\n      }\n      else {\n        return self.items[prop];\n      }\n    };\n  };\n  for (var i = 0, ii = ARRAY_METHODS.length; i < ii; i++) {\n    wrap(ARRAY_METHODS[i]);\n  }\n\n  // Include whatever files got passed to the constructor\n  this.include.apply(this, arguments);\n\n  // Fix constructor linkage\n  this.constructor = FileList;\n};\n\nFileList.prototype = new (function () {\n  var globPattern = /[*?\\[\\{]/;\n\n  var _addMatching = function (item) {\n        var matches = globSync(item.path, item.options);\n        this.items = this.items.concat(matches);\n      }\n\n    , _resolveAdd = function (item) {\n        if (globPattern.test(item.path)) {\n          _addMatching.call(this, item);\n        }\n        else {\n          this.push(item.path);\n        }\n      }\n\n    , _calculateExcludeRe = function () {\n        var pats = this.excludes.pats\n          , pat\n          , excl = []\n          , matches = [];\n\n        for (var i = 0, ii = pats.length; i < ii; i++) {\n          pat = pats[i];\n          if (typeof pat == 'string') {\n            // Glob, look up files\n            if (/[*?]/.test(pat)) {\n              matches = globSync(pat);\n              matches = matches.map(function (m) {\n                return escapeRegExpChars(m);\n              });\n              excl = excl.concat(matches);\n            }\n            // String for regex\n            else {\n              excl.push(escapeRegExpChars(pat));\n            }\n          }\n          // Regex, grab the string-representation\n          else if (pat instanceof RegExp) {\n            excl.push(pat.toString().replace(/^\\/|\\/$/g, ''));\n          }\n        }\n        if (excl.length) {\n          this.excludes.regex = new RegExp('(' + excl.join(')|(') + ')');\n        }\n        else {\n          this.excludes.regex = /^$/;\n        }\n      }\n\n    , _resolveExclude = function () {\n        var self = this;\n        _calculateExcludeRe.call(this);\n        // No `reject` method, so use reverse-filter\n        this.items = this.items.filter(function (name) {\n          return !self.shouldExclude(name);\n        });\n      };\n\n  /**\n   * Includes file-patterns in the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments should be strings\n   * for either a glob-pattern or a specific file-name, or an array of them\n   */\n  this.include = function () {\n    var args = Array.prototype.slice.call(arguments)\n        , arg\n        , includes = { items: [], options: {} };\n\n    for (var i = 0, ilen = args.length; i < ilen; i++) {\n      arg = args[i];\n\n      if (typeof arg === 'object' && !Array.isArray(arg)) {\n        merge(includes.options, arg);\n      } else {\n        includes.items = includes.items.concat(arg).filter(function (item) {\n          return !!item;\n        });\n      }\n    }\n\n    var items = includes.items.map(function(item) {\n      return { path: item, options: includes.options };\n    });\n\n    this.pendingAdd = this.pendingAdd.concat(items);\n\n    return this;\n  };\n\n  /**\n   * Indicates whether a particular file would be filtered out by the current\n   * exclusion rules for this FileList.\n   * @param {String} name The filename to check\n   * @return {Boolean} Whether or not the file should be excluded\n   */\n  this.shouldExclude = function (name) {\n    if (!this.excludes.regex) {\n      _calculateExcludeRe.call(this);\n    }\n    var excl = this.excludes;\n    return excl.regex.test(name) || excl.funcs.some(function (f) {\n      return !!f(name);\n    });\n  };\n\n  /**\n   * Excludes file-patterns from the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments can be:\n   * 1. Strings for either a glob-pattern or a specific file-name\n   * 2. Regular expression literals\n   * 3. Functions to be run on the filename that return a true/false\n   */\n  this.exclude = function () {\n    var args = Array.isArray(arguments[0]) ? arguments[0] : arguments\n      , arg;\n    for (var i = 0, ii = args.length; i < ii; i++) {\n      arg = args[i];\n      if (typeof arg == 'function' && !(arg instanceof RegExp)) {\n        this.excludes.funcs.push(arg);\n      }\n      else {\n        this.excludes.pats.push(arg);\n      }\n    }\n    if (!this.pending) {\n      _resolveExclude.call(this);\n    }\n    return this;\n  };\n\n  /**\n   * Populates the FileList from the include/exclude rules with a list of\n   * actual files\n   */\n  this.resolve = function () {\n    var item\n      , uniqueFunc = function (p, c) {\n          if (p.indexOf(c) < 0) {\n            p.push(c);\n          }\n          return p;\n        };\n    if (this.pending) {\n      this.pending = false;\n      while ((item = this.pendingAdd.shift())) {\n        _resolveAdd.call(this, item);\n      }\n      // Reduce to a unique list\n      this.items = this.items.reduce(uniqueFunc, []);\n      // Remove exclusions\n      _resolveExclude.call(this);\n    }\n    return this;\n  };\n\n  /**\n   * Convert to a plain-jane array\n   */\n  this.toArray = function () {\n    // Call slice to ensure lazy-resolution before slicing items\n    var ret = this.slice().items.slice();\n    return ret;\n  };\n\n  /**\n   * Clear any pending items -- only useful before\n   * calling `resolve`\n   */\n  this.clearInclusions = function () {\n    this.pendingAdd = [];\n    return this;\n  };\n\n  /**\n   * Clear any current exclusion rules\n   */\n  this.clearExclusions = function () {\n    this.excludes = {\n      pats: []\n    , funcs: []\n    , regex: null\n    };\n    return this;\n  };\n\n})();\n\n// Static method, used to create copy returned by special\n// array methods\nFileList.clone = function (list, items) {\n  var clone = new FileList();\n  if (items) {\n    clone.items = items;\n  }\n  clone.pendingAdd = list.pendingAdd;\n  clone.pending = list.pending;\n  for (var p in list.excludes) {\n    clone.excludes[p] = list.excludes[p];\n  }\n  return clone;\n};\n\nFileList.verbose = true\n\nexports.FileList = FileList;\n"]}