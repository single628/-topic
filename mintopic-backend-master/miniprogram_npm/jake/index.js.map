{"version":3,"sources":["jake.js","task/index.js","task/task.js","rule.js","task/file_task.js","task/directory_task.js","namespace.js","api.js","utils/index.js","utils/logger.js","utils/file.js","program.js","parseargs.js","loader.js","package_task.js","publish_task.js","test_task.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,ACHA,AFMA;AFOA,AGTA,ACHA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AMlBA,AHSA,AENA,ADGA,AFMA;AFOA,AMlBA,AHSA,AENA,ADGA,AFMA;AFOA,AMlBA,AHSA,AENA,ADGA,AFMA;AKdA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA;AKdA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA;AKdA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA;AKdA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AMlBA;ADIA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AMlBA;ADIA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AMlBA;ADIA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AMlBA,ACHA;AFOA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AMlBA,ACHA;AFOA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AMlBA,ACHA;AFOA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AHSA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AKfA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AKfA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AKfA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AMlBA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AMlBA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AMlBA,AMlBA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AMlBA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AMlBA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AMlBA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,ARwBA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,AENA,ADGA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,AQxBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA,ACHA;AFOA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,APqBA,AQxBA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ACHA,AFMA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AFMA,ADGA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,AavCA,ACHA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,AHSA,AIZA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,ACHA,AZoCA,ADGA,Ac1CA,ANkBA,AFMA;ADIA,APqBA,Ac1CA,ACHA,AZoCA,ADGA,Ac1CA,ARwBA;ADIA,APqBA,Ac1CA,ACHA,AZoCA,ADGA,Ac1CA,ARwBA;ADIA,APqBA,Ac1CA,ACHA,AZoCA,ADGA,AMlBA;ADIA,AOrBA,ACHA,AZoCA,ADGA,AMlBA;ADIA,AOrBA,ACHA,AbuCA,AMlBA;ADIA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,ACHA,AbuCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AKdA,AOrBA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA,AZoCA;AYnCA;AACA;AACA","file":"index.js","sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nif (!global.jake) {\n\n  let EventEmitter = require('events').EventEmitter;\n  // And so it begins\n  global.jake = new EventEmitter();\n\n  let fs = require('fs');\n  let chalk = require('chalk');\n  let taskNs = require('./task');\n  let Task = taskNs.Task;\n  let FileTask = taskNs.FileTask;\n  let DirectoryTask = taskNs.DirectoryTask;\n  let Rule = require('./rule').Rule;\n  let Namespace = require('./namespace').Namespace;\n  let RootNamespace = require('./namespace').RootNamespace;\n  let api = require('./api');\n  let utils = require('./utils');\n  let Program = require('./program').Program;\n  let loader = require('./loader')();\n  let pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json').toString());\n\n  const MAX_RULE_RECURSION_LEVEL = 16;\n\n  // Globalize jake and top-level API methods (e.g., `task`, `desc`)\n  Object.assign(global, api);\n\n  // Copy utils onto base jake\n  jake.logger = utils.logger;\n  jake.exec = utils.exec;\n\n  // File utils should be aliased directly on base jake as well\n  Object.assign(jake, utils.file);\n\n  // Also add top-level API methods to exported object for those who don't want to\n  // use the globals (`file` here will overwrite the 'file' utils namespace)\n  Object.assign(jake, api);\n\n  Object.assign(jake, new (function () {\n\n    this._invocationChain = [];\n    this._taskTimeout = 30000;\n\n    // Public properties\n    // =================\n    this.version = pkg.version;\n    // Used when Jake exits with a specific error-code\n    this.errorCode = null;\n    // Loads Jakefiles/jakelibdirs\n    this.loader = loader;\n    // The root of all ... namespaces\n    this.rootNamespace = new RootNamespace();\n    // Non-namespaced tasks are placed into the default\n    this.defaultNamespace = this.rootNamespace;\n    // Start in the default\n    this.currentNamespace = this.defaultNamespace;\n    // Saves the description created by a 'desc' call that prefaces a\n    // 'task' call that defines a task.\n    this.currentTaskDescription = null;\n    this.program = new Program();\n    this.FileList = require('filelist').FileList;\n    this.PackageTask = require('./package_task').PackageTask;\n    this.PublishTask = require('./publish_task').PublishTask;\n    this.TestTask = require('./test_task').TestTask;\n    this.Task = Task;\n    this.FileTask = FileTask;\n    this.DirectoryTask = DirectoryTask;\n    this.Namespace = Namespace;\n    this.Rule = Rule;\n\n    this.parseAllTasks = function () {\n      let _parseNs = function (ns) {\n        let nsTasks = ns.tasks;\n        let nsNamespaces = ns.childNamespaces;\n        for (let q in nsTasks) {\n          let nsTask = nsTasks[q];\n          jake.Task[nsTask.fullName] = nsTask;\n        }\n        for (let p in nsNamespaces) {\n          let nsNamespace = nsNamespaces[p];\n          _parseNs(nsNamespace);\n        }\n      };\n      _parseNs(jake.defaultNamespace);\n    };\n\n    /**\n     * Displays the list of descriptions avaliable for tasks defined in\n     * a Jakefile\n     */\n    this.showAllTaskDescriptions = function (f) {\n      let p;\n      let maxTaskNameLength = 0;\n      let task;\n      let padding;\n      let name;\n      let descr;\n      let filter = typeof f == 'string' ? f : null;\n\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n        task = jake.Task[p];\n        // Record the length of the longest task name -- used for\n        // pretty alignment of the task descriptions\n        if (task.description) {\n          maxTaskNameLength = p.length > maxTaskNameLength ?\n            p.length : maxTaskNameLength;\n        }\n      }\n      // Print out each entry with descriptions neatly aligned\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n        task = jake.Task[p];\n\n        //name = '\\033[32m' + p + '\\033[39m ';\n        name = chalk.green(p);\n\n        descr = task.description;\n        if (descr) {\n          descr = chalk.gray('# ' + descr);\n\n          // Create padding-string with calculated length\n          padding = (new Array(maxTaskNameLength - p.length + 2)).join(' ');\n\n          console.log('jake ' + name + padding + descr);\n        }\n      }\n    };\n\n    this.createTask = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let arg;\n      let obj;\n      let task;\n      let type;\n      let name;\n      let action;\n      let opts = {};\n      let prereqs = [];\n\n      type = args.shift();\n\n      // name, [deps], [action]\n      // Name (string) + deps (array) format\n      if (typeof args[0] == 'string') {\n        name = args.shift();\n        if (Array.isArray(args[0])) {\n          prereqs = args.shift();\n        }\n      }\n      // name:deps, [action]\n      // Legacy object-literal syntax, e.g.: {'name': ['depA', 'depB']}\n      else {\n        obj = args.shift();\n        for (let p in obj) {\n          prereqs = prereqs.concat(obj[p]);\n          name = p;\n        }\n      }\n\n      // Optional opts/callback or callback/opts\n      while ((arg = args.shift())) {\n        if (typeof arg == 'function') {\n          action = arg;\n        }\n        else {\n          opts = Object.assign(Object.create(null), arg);\n        }\n      }\n\n      task = jake.currentNamespace.resolveTask(name);\n      if (task && !action) {\n        // Task already exists and no action, just update prereqs, and return it.\n        task.prereqs = task.prereqs.concat(prereqs);\n        return task;\n      }\n\n      switch (type) {\n      case 'directory':\n        action = function () {\n          jake.mkdirP(name);\n        };\n        task = new DirectoryTask(name, prereqs, action, opts);\n        break;\n      case 'file':\n        task = new FileTask(name, prereqs, action, opts);\n        break;\n      default:\n        task = new Task(name, prereqs, action, opts);\n      }\n\n      jake.currentNamespace.addTask(task);\n\n      if (jake.currentTaskDescription) {\n        task.description = jake.currentTaskDescription;\n        jake.currentTaskDescription = null;\n      }\n\n      // FIXME: Should only need to add a new entry for the current\n      // task-definition, not reparse the entire structure\n      jake.parseAllTasks();\n\n      return task;\n    };\n\n    this.attemptRule = function (name, ns, level) {\n      let prereqRule;\n      let prereq;\n      if (level > MAX_RULE_RECURSION_LEVEL) {\n        return null;\n      }\n      // Check Rule\n      prereqRule = ns.matchRule(name);\n      if (prereqRule) {\n        prereq = prereqRule.createTask(name, level);\n      }\n      return prereq || null;\n    };\n\n    this.createPlaceholderFileTask = function (name, namespace) {\n      let parsed = name.split(':');\n      let filePath = parsed.pop(); // Strip any namespace\n      let task;\n\n      task = namespace.resolveTask(name);\n\n      // If there's not already an existing dummy FileTask for it,\n      // create one\n      if (!task) {\n        // Create a dummy FileTask only if file actually exists\n        if (fs.existsSync(filePath)) {\n          task = new jake.FileTask(filePath);\n          task.dummy = true;\n          let ns;\n          if (parsed.length) {\n            ns = namespace.resolveNamespace(parsed.join(':'));\n          }\n          else {\n            ns = namespace;\n          }\n          if (!namespace) {\n            throw new Error('Invalid namespace, cannot add FileTask');\n          }\n          ns.addTask(task);\n          // Put this dummy Task in the global Tasks list so\n          // modTime will be eval'd correctly\n          jake.Task[`${ns.path}:${filePath}`] = task;\n        }\n      }\n\n      return task || null;\n    };\n\n\n    this.run = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let program = this.program;\n      let loader = this.loader;\n      let preempt;\n      let opts;\n\n      program.parseArgs(args);\n      program.init();\n\n      preempt = program.firstPreemptiveOption();\n      if (preempt) {\n        preempt();\n      }\n      else {\n        opts = program.opts;\n        // jakefile flag set but no jakefile yet\n        if (opts.autocomplete && opts.jakefile === true) {\n          process.stdout.write('no-complete');\n          return;\n        }\n        // Load Jakefile and jakelibdir files\n        let jakefileLoaded = loader.loadFile(opts.jakefile);\n        let jakelibdirLoaded = loader.loadDirectory(opts.jakelibdir);\n\n        if(!jakefileLoaded && !jakelibdirLoaded && !opts.autocomplete) {\n          fail('No Jakefile. Specify a valid path with -f/--jakefile, ' +\n              'or place one in the current directory.');\n        }\n\n        program.run();\n      }\n    };\n\n  })());\n}\n\nmodule.exports = jake;\n","\nlet Task = require('./task').Task;\nlet FileTask = require('./file_task').FileTask;\nlet DirectoryTask = require('./directory_task').DirectoryTask;\n\nexports.Task = Task;\nexports.FileTask = FileTask;\nexports.DirectoryTask = DirectoryTask;\n\n","let EventEmitter = require('events').EventEmitter;\nlet async = require('async');\nlet chalk = require('chalk');\n// 'rule' module is required at the bottom because circular deps\n\n// Used for task value, so better not to use\n// null, since value should be unset/uninitialized\nlet UNDEFINED_VALUE;\n\nconst ROOT_TASK_NAME = '__rootTask__';\nconst POLLING_INTERVAL = 100;\n\n// Parse any positional args attached to the task-name\nfunction parsePrereqName(name) {\n  let taskArr = name.split('[');\n  let taskName = taskArr[0];\n  let taskArgs = [];\n  if (taskArr[1]) {\n    taskArgs = taskArr[1].replace(/\\]$/, '');\n    taskArgs = taskArgs.split(',');\n  }\n  return {\n    name: taskName,\n    args: taskArgs\n  };\n}\n\n/**\n  @name jake.Task\n  @class\n  @extends EventEmitter\n  @description A Jake Task\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform for this task\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nclass Task extends EventEmitter {\n\n  constructor(name, prereqs, action, options) {\n    // EventEmitter ctor takes no args\n    super();\n\n    if (name.indexOf(':') > -1) {\n      throw new Error('Task name cannot include a colon. It is used internally as namespace delimiter.');\n    }\n    let opts = options || {};\n\n    this._currentPrereqIndex = 0;\n    this._internal = false;\n    this._skipped = false;\n\n    this.name = name;\n    this.prereqs = prereqs;\n    this.action = action;\n    this.async = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.description = null;\n    this.args = [];\n    this.value = UNDEFINED_VALUE;\n    this.concurrency = 1;\n    this.startTime = null;\n    this.endTime = null;\n    this.directory = null;\n    this.namespace = null;\n\n    // Support legacy async-flag -- if not explicitly passed or falsy, will\n    // be set to empty-object\n    if (typeof opts == 'boolean' && opts === true) {\n      this.async = true;\n    }\n    else {\n      if (opts.async) {\n        this.async = true;\n      }\n      if (opts.concurrency) {\n        this.concurrency = opts.concurrency;\n      }\n    }\n\n    //Do a test on self dependencies for this task\n    if(Array.isArray(this.prereqs) && this.prereqs.indexOf(this.name) !== -1) {\n      throw new Error(\"Cannot use prereq \" + this.name + \" as a dependency of itself\");\n    }\n  }\n\n  get fullName() {\n    return this._getFullName();\n  }\n\n  _initInvocationChain() {\n    // Legacy global invocation chain\n    jake._invocationChain.push(this);\n\n    // New root chain\n    if (!this._invocationChain) {\n      this._invocationChainRoot = true;\n      this._invocationChain = [];\n      if (jake.currentRunningTask) {\n        jake.currentRunningTask._waitForChains = jake.currentRunningTask._waitForChains || [];\n        jake.currentRunningTask._waitForChains.push(this._invocationChain);\n      }\n    }\n  }\n\n  /**\n    @name jake.Task#invoke\n    @function\n    @description Runs prerequisites, then this task. If the task has already\n    been run, will not run the task again.\n   */\n  invoke() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenabled = false\n    this.runPrereqs();\n  }\n\n  /**\n    @name jake.Task#execute\n    @function\n    @description Run only this task, without prereqs. If the task has already\n    been run, *will* run the task again.\n   */\n  execute() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenable();\n    this.reenabled = true\n    this.run();\n  }\n\n  runPrereqs() {\n    if (this.prereqs && this.prereqs.length) {\n\n      if (this.concurrency > 1) {\n        async.eachLimit(this.prereqs, this.concurrency,\n\n          (name, cb) => {\n            let parsed = parsePrereqName(name);\n\n            let prereq = this.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, this.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, this.namespace);\n\n            if (!prereq) {\n              throw new Error('Unknown task \"' + name + '\"');\n            }\n\n            //Test for circular invocation\n            if(prereq === this) {\n              setImmediate(function () {\n                cb(new Error(\"Cannot use prereq \" + prereq.name + \" as a dependency of itself\"));\n              });\n            }\n\n            if (prereq.taskStatus == Task.runStatuses.DONE) {\n            //prereq already done, return\n              setImmediate(cb);\n            }\n            else {\n            //wait for complete before calling cb\n              prereq.once('_done', () => {\n                prereq.removeAllListeners('_done');\n                setImmediate(cb);\n              });\n              // Start the prereq if we are the first to encounter it\n              if (prereq.taskStatus === Task.runStatuses.UNSTARTED) {\n                prereq.taskStatus = Task.runStatuses.STARTED;\n                prereq.invoke.apply(prereq, parsed.args);\n              }\n            }\n          },\n\n          (err) => {\n          //async callback is called after all prereqs have run.\n            if (err) {\n              throw err;\n            }\n            else {\n              setImmediate(this.run.bind(this));\n            }\n          }\n        );\n      }\n      else {\n        setImmediate(this.nextPrereq.bind(this));\n      }\n    }\n    else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  nextPrereq() {\n    let self = this;\n    let index = this._currentPrereqIndex;\n    let name = this.prereqs[index];\n    let prereq;\n    let parsed;\n\n    if (name) {\n\n      parsed = parsePrereqName(name);\n\n      prereq = this.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, this.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, this.namespace);\n\n      if (!prereq) {\n        throw new Error('Unknown task \"' + name + '\"');\n      }\n\n      // Do when done\n      if (prereq.taskStatus == Task.runStatuses.DONE) {\n        self.handlePrereqDone(prereq);\n      }\n      else {\n        prereq.once('_done', () => {\n          this.handlePrereqDone(prereq);\n          prereq.removeAllListeners('_done');\n        });\n        if (prereq.taskStatus == Task.runStatuses.UNSTARTED) {\n          prereq.taskStatus = Task.runStatuses.STARTED;\n          prereq._invocationChain = this._invocationChain;\n          prereq.invoke.apply(prereq, parsed.args);\n        }\n      }\n    }\n  }\n\n  /**\n    @name jake.Task#reenable\n    @function\n    @description Reenables a task so that it can be run again.\n   */\n  reenable(deep) {\n    let prereqs;\n    let prereq;\n    this._skipped = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.value = UNDEFINED_VALUE;\n    if (deep && this.prereqs) {\n      prereqs = this.prereqs;\n      for (let i = 0, ii = prereqs.length; i < ii; i++) {\n        prereq = jake.Task[prereqs[i]];\n        if (prereq) {\n          prereq.reenable(deep);\n        }\n      }\n    }\n  }\n\n  handlePrereqDone(prereq) {\n    this._currentPrereqIndex++;\n    if (this._currentPrereqIndex < this.prereqs.length) {\n      setImmediate(this.nextPrereq.bind(this));\n    }\n    else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  isNeeded() {\n    let needed = true;\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      needed = false;\n    }\n    return needed;\n  }\n\n  run() {\n    let val, previous;\n    let hasAction = typeof this.action == 'function';\n\n    if (!this.isNeeded()) {\n      this.emit('skip');\n      this.emit('_done');\n    }\n    else {\n      if (this._invocationChain.length) {\n        previous = this._invocationChain[this._invocationChain.length - 1];\n        // If this task is repeating and its previous is equal to this, don't check its status because it was set to UNSTARTED by the reenable() method\n        if (!(this.reenabled && previous == this)) {\n          if (previous.taskStatus != Task.runStatuses.DONE) {\n            let now = (new Date()).getTime();\n            if (now - this.startTime > jake._taskTimeout) {\n              return jake.fail(`Timed out waiting for task: ${previous.name} with status of ${previous.taskStatus}`);\n            }\n            setTimeout(this.run.bind(this), POLLING_INTERVAL);\n            return;\n          }\n        }\n      }\n      if (!(this.reenabled && previous == this)) {\n        this._invocationChain.push(this);\n      }\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Starting '\" + chalk.green(this.fullName) + \"'...\");\n      }\n\n      this.startTime = (new Date()).getTime();\n      this.emit('start');\n\n      jake.currentRunningTask = this;\n\n      if (hasAction) {\n        try {\n          if (this.directory) {\n            process.chdir(this.directory);\n          }\n\n          val = this.action.apply(this, this.args);\n\n          if (typeof val == 'object' && typeof val.then == 'function') {\n            this.async = true;\n\n            val.then(\n              (result) => {\n                setImmediate(() => {\n                  this.complete(result);\n                });\n              },\n              (err) => {\n                setImmediate(() => {\n                  this.errorOut(err);\n                });\n              });\n          }\n        }\n        catch (err) {\n          this.errorOut(err);\n          return; // Bail out, not complete\n        }\n      }\n\n      if (!(hasAction && this.async)) {\n        setImmediate(() => {\n          this.complete(val);\n        });\n      }\n    }\n  }\n\n  errorOut(err) {\n    this.taskStatus = Task.runStatuses.ERROR;\n    this._invocationChain.chainStatus = Task.runStatuses.ERROR;\n    this.emit('error', err);\n  }\n\n  complete(val) {\n\n    if (Array.isArray(this._waitForChains)) {\n      let stillWaiting = this._waitForChains.some((chain) => {\n        return !(chain.chainStatus == Task.runStatuses.DONE ||\n              chain.chainStatus == Task.runStatuses.ERROR);\n      });\n      if (stillWaiting) {\n        let now = (new Date()).getTime();\n        let elapsed = now - this.startTime;\n        if (elapsed > jake._taskTimeout) {\n          return jake.fail(`Timed out waiting for task: ${this.name} with status of ${this.taskStatus}. Elapsed: ${elapsed}`);\n        }\n        setTimeout(() => {\n          this.complete(val);\n        }, POLLING_INTERVAL);\n        return;\n      }\n    }\n\n    jake._invocationChain.splice(jake._invocationChain.indexOf(this), 1);\n\n    if (this._invocationChainRoot) {\n      this._invocationChain.chainStatus = Task.runStatuses.DONE;\n    }\n\n    this._currentPrereqIndex = 0;\n\n    // If 'complete' getting called because task has been\n    // run already, value will not be passed -- leave in place\n    if (!this._skipped) {\n      this.taskStatus = Task.runStatuses.DONE;\n      this.value = val;\n\n      this.emit('complete', this.value);\n      this.emit('_done');\n\n      this.endTime = (new Date()).getTime();\n      let taskTime = this.endTime - this.startTime;\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Finished '\" + chalk.green(this.fullName) + \"' after \" + chalk.magenta(taskTime + ' ms'));\n      }\n\n    }\n  }\n\n  _getFullName() {\n    let ns = this.namespace;\n    let path = (ns && ns.path) || '';\n    path = (path && path.split(':')) || [];\n    if (this.namespace !== jake.defaultNamespace) {\n      path.push(this.namespace.name);\n    }\n    path.push(this.name);\n    return path.join(':');\n  }\n\n  static getBaseNamespacePath(fullName) {\n    return fullName.split(':').slice(0, -1).join(':');\n  }\n\n  static getBaseTaskName(fullName) {\n    return fullName.split(':').pop();\n  }\n}\n\nTask.runStatuses = {\n  UNSTARTED: 'unstarted',\n  DONE: 'done',\n  STARTED: 'started',\n  ERROR: 'error'\n};\n\nTask.ROOT_TASK_NAME = ROOT_TASK_NAME;\n\nexports.Task = Task;\n\n// Required here because circular deps\nrequire('../rule');\n\n","let path = require('path');\nlet fs = require('fs');\nlet Task = require('./task/task').Task;\n\n// Split a task to two parts, name space and task name.\n// For example, given 'foo:bin/a%.c', return an object with\n// - 'ns'     : foo\n// - 'name'   : bin/a%.c\nfunction splitNs(task) {\n  let parts = task.split(':');\n  let name = parts.pop();\n  let ns = resolveNs(parts);\n  return {\n    'name' : name,\n    'ns'   : ns\n  };\n}\n\n// Return the namespace based on an array of names.\n// For example, given ['foo', 'baz' ], return the namespace\n//\n//   default -> foo -> baz\n//\n// where default is the global root namespace\n// and -> means child namespace.\nfunction resolveNs(parts) {\n  let  ns = jake.defaultNamespace;\n  for(let i = 0, l = parts.length; ns && i < l; i++) {\n    ns = ns.childNamespaces[parts[i]];\n  }\n  return ns;\n}\n\n// Given a pattern p, say 'foo:bin/a%.c'\n// Return an object with\n// - 'ns'     : foo\n// - 'dir'    : bin\n// - 'prefix' : a\n// - 'suffix' : .c\nfunction resolve(p) {\n  let task = splitNs(p);\n  let name  = task.name;\n  let ns    = task.ns;\n  let split = path.basename(name).split('%');\n  return {\n    ns: ns,\n    dir: path.dirname(name),\n    prefix: split[0],\n    suffix: split[1]\n  };\n}\n\n// Test whether string a is a suffix of string b\nfunction stringEndWith(a, b) {\n  let l;\n  return (l = b.lastIndexOf(a)) == -1 ? false : l + a.length == b.length;\n}\n\n// Replace the suffix a of the string s with b.\n// Note that, it is assumed a is a suffix of s.\nfunction stringReplaceSuffix(s, a, b) {\n  return s.slice(0, s.lastIndexOf(a)) + b;\n}\n\nclass Rule {\n  constructor(opts) {\n    this.pattern = opts.pattern;\n    this.source = opts.source;\n    this.prereqs = opts.prereqs;\n    this.action = opts.action;\n    this.opts = opts.opts;\n    this.desc =  opts.desc;\n    this.ns = opts.ns;\n  }\n\n  // Create a file task based on this rule for the specified\n  // task-name\n  // ======\n  // FIXME: Right now this just throws away any passed-in args\n  // for the synthsized task (taskArgs param)\n  // ======\n  createTask(fullName, level) {\n    let self = this;\n    let pattern;\n    let source;\n    let action;\n    let opts;\n    let prereqs;\n    let valid;\n    let src;\n    let tNs;\n    let createdTask;\n    let name = Task.getBaseTaskName(fullName);\n    let nsPath = Task.getBaseNamespacePath(fullName);\n    let ns = this.ns.resolveNamespace(nsPath);\n\n    pattern = this.pattern;\n    source = this.source;\n\n    if (typeof source == 'string') {\n      src = Rule.getSource(name, pattern, source);\n    }\n    else {\n      src = source(name);\n    }\n\n    // TODO: Write a utility function that appends a\n    // taskname to a namespace path\n    src = nsPath.split(':').filter(function (item) {\n      return !!item;\n    }).concat(src).join(':');\n\n    // Generate the prerequisite for the matching task.\n    //    It is the original prerequisites plus the prerequisite\n    //    representing source file, i.e.,\n    //\n    //      rule( '%.o', '%.c', ['some.h'] ...\n    //\n    //    If the objective is main.o, then new task should be\n    //\n    //      file( 'main.o', ['main.c', 'some.h' ] ...\n    prereqs = this.prereqs.slice(); // Get a copy to work with\n    prereqs.unshift(src);\n\n    // Prereq should be:\n    // 1. an existing task\n    // 2. an existing file on disk\n    // 3. a valid rule (i.e., not at too deep a level)\n    valid = prereqs.some(function (p) {\n      let ns = self.ns;\n      return ns.resolveTask(p) ||\n        fs.existsSync(Task.getBaseTaskName(p)) ||\n        jake.attemptRule(p, ns, level + 1);\n    });\n\n    // If any of the prereqs aren't valid, the rule isn't valid\n    if (!valid) {\n      return null;\n    }\n    // Otherwise, hunky-dory, finish creating the task for the rule\n    else {\n      // Create the action for the task\n      action = function () {\n        let task = this;\n        self.action.apply(task);\n      };\n\n      opts = this.opts;\n\n      // Insert the file task into Jake\n      //\n      // Since createTask function stores the task as a child task\n      // of currentNamespace. Here we temporariliy switch the namespace.\n      // FIXME: Should allow optional ns passed in instead of this hack\n      tNs = jake.currentNamespace;\n      jake.currentNamespace = ns;\n      createdTask = jake.createTask('file', name, prereqs, action, opts);\n      createdTask.source = src.split(':').pop();\n      jake.currentNamespace = tNs;\n\n      return createdTask;\n    }\n  }\n\n  match(name) {\n    return Rule.match(this.pattern, name);\n  }\n\n  // Test wether the a prerequisite matchs the pattern.\n  // The arg 'pattern' does not have namespace as prefix.\n  // For example, the following tests are true\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    bin/main.o\n  //   bin/%.o      |    foo:bin/main.o\n  //\n  // The following tests are false (trivally)\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    foobin/main.o\n  //   bin/%.o      |    bin/main.oo\n  static match(pattern, name) {\n    let p;\n    let task;\n    let obj;\n    let filename;\n\n    if (pattern instanceof RegExp) {\n      return pattern.test(name);\n    }\n    else if (pattern.indexOf('%') == -1) {\n      // No Pattern. No Folder. No Namespace.\n      // A Simple Suffix Rule. Just test suffix\n      return stringEndWith(pattern, name);\n    }\n    else {\n      // Resolve the dir, prefix and suffix of pattern\n      p = resolve(pattern);\n\n      // Resolve the namespace and task-name\n      task = splitNs(name);\n      name = task.name;\n\n      // Set the objective as the task-name\n      obj = name;\n\n      // Namespace is already matched.\n\n      // Check dir\n      if (path.dirname(obj) != p.dir) {\n        return false;\n      }\n\n      filename = path.basename(obj);\n\n      // Check file name length\n      if ((p.prefix.length + p.suffix.length + 1) > filename.length) {\n        // Length does not match.\n        return false;\n      }\n\n      // Check prefix\n      if (filename.indexOf(p.prefix) !== 0) {\n        return false;\n      }\n\n      // Check suffix\n      if (!stringEndWith(p.suffix, filename)) {\n        return false;\n      }\n\n      // OK. Find a match.\n      return true;\n    }\n  }\n\n  // Generate the source based on\n  //  - name    name for the synthesized task\n  //  - pattern    pattern for the objective\n  //  - source    pattern for the source\n  //\n  // Return the source with properties\n  //  - dep      the prerequisite of source\n  //             (with the namespace)\n  //\n  //  - file     the file name of source\n  //             (without the namespace)\n  //\n  // For example, given\n  //\n  //  - name   foo:bin/main.o\n  //  - pattern    bin/%.o\n  //  - source    src/%.c\n  //\n  //    return 'foo:src/main.c',\n  //\n  static getSource(name, pattern, source) {\n    let dep;\n    let pat;\n    let match;\n    let file;\n    let src;\n\n    // Regex pattern -- use to look up the extension\n    if (pattern instanceof RegExp) {\n      match = pattern.exec(name);\n      if (match) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = stringReplaceSuffix(name, match[0], source);\n        }\n      }\n    }\n    // Assume string\n    else {\n      // Simple string suffix replacement\n      if (pattern.indexOf('%') == -1) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = stringReplaceSuffix(name, pattern, source);\n        }\n      }\n      // Percent-based substitution\n      else {\n        pat = pattern.replace('%', '(.*?)');\n        pat = new RegExp(pat);\n        match = pat.exec(name);\n        if (match) {\n          if (typeof source == 'function') {\n            src = source(name);\n          }\n          else {\n            file = match[1];\n            file = source.replace('%', file);\n            dep = match[0];\n            src = name.replace(dep, file);\n          }\n        }\n      }\n    }\n\n    return src;\n  }\n}\n\n\nexports.Rule = Rule;\n","let fs = require('fs');\nlet Task = require('./task').Task;\n\nfunction isFileOrDirectory(t) {\n  return (t instanceof FileTask ||\n          t instanceof DirectoryTask);\n}\n\nfunction isFile(t) {\n  return (t instanceof FileTask && !(t instanceof DirectoryTask));\n}\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.FileTask\n  @class`\n  @extentds Task\n  @description A Jake FileTask\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform to create this file\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nclass FileTask extends Task {\n  constructor(...args) {\n    super(...args);\n    this.dummy = false;\n    if (fs.existsSync(this.name)) {\n      this.updateModTime();\n    }\n    else {\n      this.modTime = null;\n    }\n  }\n\n  isNeeded() {\n    let prereqs = this.prereqs;\n    let prereqName;\n    let prereqTask;\n\n    // No repeatsies\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      return false;\n    }\n    // The always-make override\n    else if (jake.program.opts['always-make']) {\n      return true;\n    }\n    // Default case\n    else {\n\n      // We need either an existing file, or an action to create one.\n      // First try grabbing the actual mod-time of the file\n      try {\n        this.updateModTime();\n      }\n      // Then fall back to looking for an action\n      catch(e) {\n        if (typeof this.action == 'function') {\n          return true;\n        }\n        else {\n          throw new Error('File-task ' + this.fullName + ' has no ' +\n            'existing file, and no action to create one.');\n        }\n      }\n\n      // Compare mod-time of all the prereqs with its mod-time\n      // If any prereqs are newer, need to run the action to update\n      if (prereqs && prereqs.length) {\n        for (let i = 0, ii = prereqs.length; i < ii; i++) {\n          prereqName = prereqs[i];\n          prereqTask = this.namespace.resolveTask(prereqName) ||\n            jake.createPlaceholderFileTask(prereqName, this.namespace);\n          // Run the action if:\n          // 1. The prereq is a normal task (not file/dir)\n          // 2. The prereq is a file-task with a mod-date more recent than\n          // the one for this file/dir\n          if (prereqTask) {\n            if (!isFileOrDirectory(prereqTask) ||\n                (isFile(prereqTask) && prereqTask.modTime > this.modTime)) {\n              return true;\n            }\n          }\n        }\n      }\n      // File/dir has no prereqs, and exists -- no need to run\n      else {\n        // Effectively done\n        this.taskStatus = Task.runStatuses.DONE;\n        return false;\n      }\n    }\n  }\n\n  updateModTime() {\n    let stats = fs.statSync(this.name);\n    this.modTime = stats.mtime;\n  }\n\n  complete() {\n    if (!this.dummy) {\n      this.updateModTime();\n    }\n    // Hackity hack\n    Task.prototype.complete.apply(this, arguments);\n  }\n\n}\n\nexports.FileTask = FileTask;\n\n// DirectoryTask is a subclass of FileTask, depends on it\n// being defined\nlet DirectoryTask = require('./directory_task').DirectoryTask;\n\n","let fs = require('fs');\nlet FileTask = require('./file_task').FileTask;\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.DirectoryTask\n  @constructor\n  @augments EventEmitter\n  @augments jake.Task\n  @augments jake.FileTask\n  @description A Jake DirectoryTask\n\n  @param {String} name The name of the directory to create.\n */\nclass DirectoryTask extends FileTask {\n  constructor(...args) {\n    super(...args);\n    if (fs.existsSync(this.name)) {\n      this.updateModTime();\n    }\n    else {\n      this.modTime = null;\n    }\n  }\n}\n\nexports.DirectoryTask = DirectoryTask;\n","const ROOT_NAMESPACE_NAME = '__rootNamespace__';\n\nclass Namespace {\n  constructor(name, parentNamespace) {\n    this.name = name;\n    this.parentNamespace = parentNamespace;\n    this.childNamespaces = {};\n    this.tasks = {};\n    this.rules = {};\n    this.path = this.getPath();\n  }\n\n  get fullName() {\n    return this._getFullName();\n  }\n\n  addTask(task) {\n    this.tasks[task.name] = task;\n    task.namespace = this;\n  }\n\n  resolveTask(name) {\n    if (!name) {\n      return;\n    }\n\n    let taskPath = name.split(':');\n    let taskName = taskPath.pop();\n    let task;\n    let ns;\n\n    // Namespaced, return either relative to current, or from root\n    if (taskPath.length) {\n      taskPath = taskPath.join(':');\n      ns = this.resolveNamespace(taskPath) ||\n        Namespace.ROOT_NAMESPACE.resolveNamespace(taskPath);\n      task = (ns && ns.resolveTask(taskName));\n    }\n    // Bare task, return either local, or top-level\n    else {\n      task = this.tasks[name] || Namespace.ROOT_NAMESPACE.tasks[name];\n    }\n\n    return task || null;\n  }\n\n\n  resolveNamespace(relativeName) {\n    if (!relativeName) {\n      return this;\n    }\n\n    let parts = relativeName.split(':');\n    let ns = this;\n\n    for (let i = 0, ii = parts.length; (ns && i < ii); i++) {\n      ns = ns.childNamespaces[parts[i]];\n    }\n\n    return ns || null;\n  }\n\n  matchRule(relativeName) {\n    let parts = relativeName.split(':');\n    parts.pop();\n    let ns = this.resolveNamespace(parts.join(':'));\n    let rules = ns ? ns.rules : [];\n    let r;\n    let match;\n\n    for (let p in rules) {\n      r = rules[p];\n      if (r.match(relativeName)) {\n        match = r;\n      }\n    }\n\n    return (ns && match) ||\n        (this.parentNamespace &&\n        this.parentNamespace.matchRule(relativeName));\n  }\n\n  getPath() {\n    let parts = [];\n    let next = this.parentNamespace;\n    while (next) {\n      parts.push(next.name);\n      next = next.parentNamespace;\n    }\n    parts.pop(); // Remove '__rootNamespace__'\n    return parts.reverse().join(':');\n  }\n\n  _getFullName() {\n    let path = this.path;\n    path = (path && path.split(':')) || [];\n    path.push(this.name);\n    return path.join(':');\n  }\n\n  isRootNamespace() {\n    return !this.parentNamespace;\n  }\n}\n\nclass RootNamespace extends Namespace {\n  constructor() {\n    super(ROOT_NAMESPACE_NAME, null);\n    Namespace.ROOT_NAMESPACE = this;\n  }\n}\n\nmodule.exports.Namespace = Namespace;\nmodule.exports.RootNamespace = RootNamespace;\n\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet { uuid } = require('./utils');\n\nlet api = new (function () {\n  /**\n    @name task\n    @static\n    @function\n    @description Creates a Jake Task\n    `\n    @param {String} name The name of the Task\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n\n    @example\n    desc('This is the default task.');\n    task('default', function (params) {\n      console.log('This is the default task.');\n    });\n\n    desc('This task has prerequisites.');\n    task('hasPrereqs', ['foo', 'bar', 'baz'], function (params) {\n      console.log('Ran some prereqs first.');\n    });\n\n    desc('This is an asynchronous task.');\n    task('asyncTask', function () {\n      setTimeout(complete, 1000);\n    }, {async: true});\n   */\n  this.task = function (name, prereqs, action, opts) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('task');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name rule\n    @static\n    @function\n    @description Creates a Jake Suffix Rule\n    `\n    @param {String} pattern The suffix name of the objective\n    @param {String} source The suffix name of the objective\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n    @example\n    desc('This is a rule, which does not support namespace or pattern.');\n    rule('.o', '.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This rule has prerequisites.');\n    rule('.o', '.c', ['util.h'], {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is a rule with patterns.');\n    rule('%.o', '%.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is another rule with patterns.');\n    rule('obj/%.o', 'src/%.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is an example with chain rules.');\n    rule('%.pdf', '%.dvi', {async: true}, function () {\n      let cmd = util.format('dvipdfm %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    rule('%.dvi', '%.tex', {async: true}, function () {\n      let cmd = util.format('latex %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This rule has a namespace.');\n    task('default', ['debug:obj/main.o]);\n\n    namespace('debug', {async: true}, function() {\n      rule('obj/%.o', 'src/%.c', function () {\n        // ...\n      });\n    }\n   */\n  this.rule = function () {\n    let args = Array.prototype.slice.call(arguments);\n    let arg;\n    let pattern = args.shift();\n    let source = args.shift();\n    let prereqs = [];\n    let action = function () {};\n    let opts = {};\n    let key = pattern.toString(); // May be a RegExp\n\n    while ((arg = args.shift())) {\n      if (typeof arg == 'function') {\n        action = arg;\n      }\n      else if (Array.isArray(arg)) {\n        prereqs = arg;\n      }\n      else {\n        opts = arg;\n      }\n    }\n\n    jake.currentNamespace.rules[key] = new jake.Rule({\n      pattern: pattern,\n      source: source,\n      prereqs: prereqs,\n      action: action,\n      opts: opts,\n      desc: jake.currentTaskDescription,\n      ns: jake.currentNamespace\n    });\n    jake.currentTaskDescription = null;\n  };\n\n  /**\n    @name directory\n    @static\n    @function\n    @description Creates a Jake DirectoryTask. Can be used as a prerequisite\n    for FileTasks, or for simply ensuring a directory exists for use with a\n    Task's action.\n    `\n    @param {String} name The name of the DiretoryTask\n\n    @example\n\n    // Creates the package directory for distribution\n    directory('pkg');\n   */\n  this.directory = function (name) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('directory');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name file\n    @static\n    @function\n    @description Creates a Jake FileTask.\n    `\n    @param {String} name The name of the FileTask\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to create this file, if it doesn't\n    exist already.\n    @param {Object} [opts]\n      @param {Array} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n\n   */\n  this.file = function (name, prereqs, action, opts) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('file');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name desc\n    @static\n    @function\n    @description Creates a description for a Jake Task (or FileTask,\n    DirectoryTask). When invoked, the description that iscreated will\n    be associated with whatever Task is created next.\n    `\n    @param {String} description The description for the Task\n   */\n  this.desc = function (description) {\n    jake.currentTaskDescription = description;\n  };\n\n  /**\n    @name namespace\n    @static\n    @function\n    @description Creates a namespace which allows logical grouping\n    of tasks, and prevents name-collisions with task-names. Namespaces\n    can be nested inside of other namespaces.\n    `\n    @param {String} name The name of the namespace\n    @param {Function} scope The enclosing scope for the namespaced tasks\n\n    @example\n    namespace('doc', function () {\n      task('generate', ['doc:clobber'], function () {\n        // Generate some docs\n      });\n\n      task('clobber', function () {\n        // Clobber the doc directory first\n      });\n    });\n   */\n  this.namespace = function (name, closure) {\n    let curr = jake.currentNamespace;\n    let ns = curr.childNamespaces[name] || new jake.Namespace(name, curr);\n    let fn = closure || function () {};\n    curr.childNamespaces[name] = ns;\n    jake.currentNamespace = ns;\n    fn();\n    jake.currentNamespace = curr;\n    jake.currentTaskDescription = null;\n    return ns;\n  };\n\n  /**\n    @name complete\n    @static\n    @function\n    @description Completes an asynchronous task, allowing Jake's\n    execution to proceed to the next task. Calling complete globally or without\n    arguments completes the last task on the invocationChain. If you use parallel\n    execution of prereqs this will probably complete a wrong task. You should call this\n    function with this task as the first argument, before the optional return value.\n    Alternatively you can call task.complete()\n    `\n    @example\n    task('generate', ['doc:clobber'], function () {\n      exec('./generate_docs.sh', function (err, stdout, stderr) {\n        if (err || stderr) {\n          fail(err || stderr);\n        }\n        else {\n          console.log(stdout);\n          complete();\n        }\n      });\n    }, {async: true});\n   */\n  this.complete = function (task, val) {\n    //this should detect if the first arg is a task, but I guess it should be more thorough\n    if(task && task. _currentPrereqIndex >=0 ) {\n      task.complete(val);\n    }\n    else {\n      val = task;\n      if(jake._invocationChain.length > 0) {\n        jake._invocationChain[jake._invocationChain.length-1].complete(val);\n      }\n    }\n  };\n\n  /**\n    @name fail\n    @static\n    @function\n    @description Causes Jake execution to abort with an error.\n    Allows passing an optional error code, which will be used to\n    set the exit-code of exiting process.\n    `\n    @param {Error|String} err The error to thow when aborting execution.\n    If this argument is an Error object, it will simply be thrown. If\n    a String, it will be used as the error-message. (If it is a multi-line\n    String, the first line will be used as the Error message, and the\n    remaining lines will be used as the error-stack.)\n\n    @example\n    task('createTests, function () {\n      if (!fs.existsSync('./tests')) {\n        fail('Test directory does not exist.');\n      }\n      else {\n        // Do some testing stuff ...\n      }\n    });\n   */\n  this.fail = function (err, code) {\n    let msg;\n    let errObj;\n    if (code) {\n      jake.errorCode = code;\n    }\n    if (err) {\n      if (typeof err == 'string') {\n        // Use the initial or only line of the error as the error-message\n        // If there was a multi-line error, use the rest as the stack\n        msg = err.split('\\n');\n        errObj = new Error(msg.shift());\n        if (msg.length) {\n          errObj.stack = msg.join('\\n');\n        }\n        throw errObj;\n      }\n      else if (err instanceof Error) {\n        throw err;\n      }\n      else {\n        throw new Error(err.toString());\n      }\n    }\n    else {\n      throw new Error();\n    }\n  };\n\n  this.packageTask = function (name, version, prereqs, definition) {\n    return new jake.PackageTask(name, version, prereqs, definition);\n  };\n\n  this.publishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  };\n\n  // Backward-compat\n  this.npmPublishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  };\n\n  this.testTask = function () {\n    let ctor = function () {};\n    let t;\n    ctor.prototype = jake.TestTask.prototype;\n    t = new ctor();\n    jake.TestTask.apply(t, arguments);\n    return t;\n  };\n\n  this.setTaskTimeout = function (t) {\n    this._taskTimeout = t;\n  };\n\n  this.setSeriesAutoPrefix = function (prefix) {\n    this._seriesAutoPrefix = prefix;\n  };\n\n  this.series = function (...args) {\n    let prereqs = args.map((arg) => {\n      let name = (this._seriesAutoPrefix || '') + arg.name;\n      jake.task(name, arg);\n      return name;\n    });\n    let seriesName = uuid();\n    let seriesTask = jake.task(seriesName, prereqs);\n    seriesTask._internal = true;\n    let res = function () {\n      return new Promise((resolve) => {\n        seriesTask.invoke();\n        seriesTask.on('complete', (val) => {\n          resolve(val);\n        });\n      });\n    };\n    Object.defineProperty(res, 'name', {value: uuid(),\n      writable: false});\n    return res;\n  };\n\n})();\n\nmodule.exports = api;\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n\nlet util = require('util'); // Native Node util module\nlet spawn = require('child_process').spawn;\nlet EventEmitter = require('events').EventEmitter;\nlet logger = require('./logger');\nlet file = require('./file');\nlet Exec;\n\nconst _UUID_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\nlet parseArgs = function (argumentsObj) {\n  let args;\n  let arg;\n  let cmds;\n  let callback;\n  let opts = {\n    interactive: false,\n    printStdout: false,\n    printStderr: false,\n    breakOnError: true\n  };\n\n  args = Array.prototype.slice.call(argumentsObj);\n\n  cmds = args.shift();\n  // Arrayize if passed a single string command\n  if (typeof cmds == 'string') {\n    cmds = [cmds];\n  }\n  // Make a copy if it's an actual list\n  else {\n    cmds = cmds.slice();\n  }\n\n  // Get optional callback or opts\n  while((arg = args.shift())) {\n    if (typeof arg == 'function') {\n      callback = arg;\n    }\n    else if (typeof arg == 'object') {\n      opts = Object.assign(opts, arg);\n    }\n  }\n\n  // Backward-compat shim\n  if (typeof opts.stdout != 'undefined') {\n    opts.printStdout = opts.stdout;\n    delete opts.stdout;\n  }\n  if (typeof opts.stderr != 'undefined') {\n    opts.printStderr = opts.stderr;\n    delete opts.stderr;\n  }\n\n  return {\n    cmds: cmds,\n    opts: opts,\n    callback: callback\n  };\n};\n\n/**\n  @name jake\n  @namespace jake\n*/\nlet utils = new (function () {\n  /**\n    @name jake.exec\n    @static\n    @function\n    @description Executes shell-commands asynchronously with an optional\n    final callback.\n    `\n    @param {String[]} cmds The list of shell-commands to execute\n    @param {Object} [opts]\n      @param {Boolean} [opts.printStdout=false] Print stdout from each command\n      @param {Boolean} [opts.printStderr=false] Print stderr from each command\n      @param {Boolean} [opts.breakOnError=true] Stop further execution on\n      the first error.\n      @param {Boolean} [opts.windowsVerbatimArguments=false] Don't translate\n      arguments on Windows.\n    @param {Function} [callback] Callback to run after executing  the\n    commands\n\n    @example\n    let cmds = [\n          'echo \"showing directories\"'\n        , 'ls -al | grep ^d'\n        , 'echo \"moving up a directory\"'\n        , 'cd ../'\n        ]\n      , callback = function () {\n          console.log('Finished running commands.');\n        }\n    jake.exec(cmds, {stdout: true}, callback);\n   */\n  this.exec = function (a, b, c) {\n    let parsed = parseArgs(arguments);\n    let cmds = parsed.cmds;\n    let opts = parsed.opts;\n    let callback = parsed.callback;\n\n    let ex = new Exec(cmds, opts, callback);\n\n    ex.addListener('error', function (msg, code) {\n      if (opts.breakOnError) {\n        fail(msg, code);\n      }\n    });\n    ex.run();\n\n    return ex;\n  };\n\n  this.createExec = function (a, b, c) {\n    return new Exec(a, b, c);\n  };\n\n  // From Math.uuid.js, https://github.com/broofa/node-uuid\n  // Robert Kieffer (robert@broofa.com), MIT license\n  this.uuid = function (length, radix) {\n    var chars = _UUID_CHARS\n      , uuid = []\n      , r\n      , i;\n\n    radix = radix || chars.length;\n\n    if (length) {\n      // Compact form\n      i = -1;\n      while (++i < length) {\n        uuid[i] = chars[0 | Math.random()*radix];\n      }\n    } else {\n      // rfc4122, version 4 form\n\n      // rfc4122 requires these characters\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n      uuid[14] = '4';\n\n      // Fill in random data.  At i==19 set the high bits of clock sequence as\n      // per rfc4122, sec. 4.1.5\n      i = -1;\n      while (++i < 36) {\n        if (!uuid[i]) {\n          r = 0 | Math.random()*16;\n          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n        }\n      }\n    }\n\n    return uuid.join('');\n  };\n\n})();\n\nExec = function () {\n  let parsed = parseArgs(arguments);\n  let cmds = parsed.cmds;\n  let opts = parsed.opts;\n  let callback = parsed.callback;\n\n  this._cmds = cmds;\n  this._callback = callback;\n  this._config = opts;\n};\n\nutil.inherits(Exec, EventEmitter);\n\nObject.assign(Exec.prototype, new (function () {\n\n  let _run = function () {\n    let self = this;\n    let sh;\n    let cmd;\n    let args;\n    let next = this._cmds.shift();\n    let config = this._config;\n    let errData = '';\n    let shStdio;\n    let handleStdoutData = function (data) {\n      self.emit('stdout', data);\n    };\n    let handleStderrData = function (data) {\n      let d = data.toString();\n      self.emit('stderr', data);\n      // Accumulate the error-data so we can use it as the\n      // stack if the process exits with an error\n      errData += d;\n    };\n\n    // Keep running as long as there are commands in the array\n    if (next) {\n      let spawnOpts = {};\n      this.emit('cmdStart', next);\n\n      // Ganking part of Node's child_process.exec to get cmdline args parsed\n      if (process.platform == 'win32') {\n        cmd = 'cmd';\n        args = ['/c', next];\n        if (config.windowsVerbatimArguments) {\n          spawnOpts.windowsVerbatimArguments = true;\n        }\n      }\n      else {\n        cmd = '/bin/sh';\n        args = ['-c', next];\n      }\n\n      if (config.interactive) {\n        spawnOpts.stdio = 'inherit';\n        sh = spawn(cmd, args, spawnOpts);\n      }\n      else {\n        shStdio = [\n          process.stdin\n        ];\n        if (config.printStdout) {\n          shStdio.push(process.stdout);\n        }\n        else {\n          shStdio.push('pipe');\n        }\n        if (config.printStderr) {\n          shStdio.push(process.stderr);\n        }\n        else {\n          shStdio.push('pipe');\n        }\n        spawnOpts.stdio = shStdio;\n        sh = spawn(cmd, args, spawnOpts);\n        if (!config.printStdout) {\n          sh.stdout.addListener('data', handleStdoutData);\n        }\n        if (!config.printStderr) {\n          sh.stderr.addListener('data', handleStderrData);\n        }\n      }\n\n      // Exit, handle err or run next\n      sh.on('exit', function (code) {\n        let msg;\n        if (code !== 0) {\n          msg = errData || 'Process exited with error.';\n          msg = msg.trim();\n          self.emit('error', msg, code);\n        }\n        if (code === 0 || !config.breakOnError) {\n          self.emit('cmdEnd', next);\n          setTimeout(function () { _run.call(self); }, 0);\n        }\n      });\n\n    }\n    else {\n      self.emit('end');\n      if (typeof self._callback == 'function') {\n        self._callback();\n      }\n    }\n  };\n\n  this.append = function (cmd) {\n    this._cmds.push(cmd);\n  };\n\n  this.run = function () {\n    _run.call(this);\n  };\n\n})());\n\nutils.Exec = Exec;\nutils.file = file;\nutils.logger = logger;\n\nmodule.exports = utils;\n\n","let util = require('util');\n\nlet logger = new (function () {\n  let _output = function (type, out) {\n    let quiet = typeof jake != 'undefined' && jake.program &&\n        jake.program.opts && jake.program.opts.quiet;\n    let msg;\n    if (!quiet) {\n      msg = typeof out == 'string' ? out : util.inspect(out);\n      console[type](msg);\n    }\n  };\n\n  this.log = function (out) {\n    _output('log', out);\n  };\n\n  this.error = function (out) {\n    _output('error', out);\n  };\n\n})();\n\nmodule.exports = logger;\n","/*\n * Utilities: A classic collection of JavaScript utilities\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet fs = require('fs');\nlet path = require('path');\n\n/**\n  @name file\n  @namespace file\n*/\n\nlet fileUtils = new (function () {\n\n  // Recursively copy files and directories\n  let _copyFile = function (fromPath, toPath, opts) {\n    let from = path.normalize(fromPath)\n    let to = path.normalize(toPath)\n    let options = opts || {}\n    let fromStat;\n    let toStat;\n    let destExists;\n    let destDoesNotExistErr;\n    let content;\n    let filename;\n    let dirContents;\n    let targetDir;\n\n    fromStat = fs.statSync(from);\n\n    try {\n      //console.dir(to + ' destExists');\n      toStat = fs.statSync(to);\n      destExists = true;\n    }\n    catch(e) {\n      //console.dir(to + ' does not exist');\n      destDoesNotExistErr = e;\n      destExists = false;\n    }\n    // Destination dir or file exists, copy into (directory)\n    // or overwrite (file)\n    if (destExists) {\n\n      // If there's a rename-via-copy file/dir name passed, use it.\n      // Otherwise use the actual file/dir name\n      filename = options.rename || path.basename(from);\n\n      // Copying a directory\n      if (fromStat.isDirectory()) {\n        dirContents = fs.readdirSync(from);\n        targetDir = path.join(to, filename);\n        // We don't care if the target dir already exists\n        try {\n          fs.mkdirSync(targetDir, {mode: fromStat.mode & 0o777});\n        }\n        catch(e) {\n          if (e.code !== 'EEXIST') {\n            throw e;\n          }\n        }\n        for (let i = 0, ii = dirContents.length; i < ii; i++) {\n          _copyFile(path.join(from, dirContents[i]), targetDir, {preserveMode: options.preserveMode});\n        }\n      }\n      // Copying a file\n      else {\n        content = fs.readFileSync(from);\n        let mode = fromStat.mode & 0o777;\n        let targetFile = to;\n\n        if (toStat.isDirectory()) {\n          targetFile = path.join(to, filename);\n        }\n\n        let fileExists = fs.existsSync(targetFile);\n        fs.writeFileSync(targetFile, content);\n\n        // If the file didn't already exist, use the original file mode.\n        // Otherwise, only update the mode if preserverMode is true.\n        if(!fileExists || options.preserveMode) {\n          fs.chmodSync(targetFile, mode);\n        }\n      }\n    }\n    // Dest doesn't exist, can't create it\n    else {\n      throw destDoesNotExistErr;\n    }\n  };\n\n  // Remove the given directory\n  let _rmDir = function (dirPath) {\n    let dir = path.normalize(dirPath);\n    let paths = [];\n    paths = fs.readdirSync(dir);\n    paths.forEach(function (p) {\n      let curr = path.join(dir, p);\n      let stat = fs.lstatSync(curr);\n      if (stat.isDirectory()) {\n        _rmDir(curr);\n      }\n      else {\n        try {\n          fs.unlinkSync(curr);\n        } catch(e) {\n          if (e.code === 'EPERM') {\n            fs.chmodSync(curr, parseInt(666, 8));\n            fs.unlinkSync(curr);\n          } else {\n            throw e;\n          }\n        }\n      }\n    });\n    fs.rmdirSync(dir);\n  };\n\n  /**\n    @name file#cpR\n    @public\n    @function\n    @description Copies a directory/file to a destination\n    @param {String} fromPath The source path to copy from\n    @param {String} toPath The destination path to copy to\n    @param {Object} opts Options to use\n      @param {Boolean} [opts.preserveMode] If target file already exists, this\n        determines whether the original file's mode is copied over. The default of\n        false mimics the behavior of the `cp` command line tool. (Default: false)\n  */\n  this.cpR = function (fromPath, toPath, options) {\n    let from = path.normalize(fromPath);\n    let to = path.normalize(toPath);\n    let toStat;\n    let doesNotExistErr;\n    let filename;\n    let opts = options || {};\n\n    if (from == to) {\n      throw new Error('Cannot copy ' + from + ' to itself.');\n    }\n\n    // Handle rename-via-copy\n    try {\n      toStat = fs.statSync(to);\n    }\n    catch(e) {\n      doesNotExistErr = e;\n\n      // Get abs path so it's possible to check parent dir\n      if (!this.isAbsolute(to)) {\n        to = path.join(process.cwd(), to);\n      }\n\n      // Save the file/dir name\n      filename = path.basename(to);\n      // See if a parent dir exists, so there's a place to put the\n      /// renamed file/dir (resets the destination for the copy)\n      to = path.dirname(to);\n      try {\n        toStat = fs.statSync(to);\n      }\n      catch(e) {}\n      if (toStat && toStat.isDirectory()) {\n        // Set the rename opt to pass to the copy func, will be used\n        // as the new file/dir name\n        opts.rename = filename;\n        //console.log('filename ' + filename);\n      }\n      else {\n        throw doesNotExistErr;\n      }\n    }\n\n    _copyFile(from, to, opts);\n  };\n\n  /**\n    @name file#mkdirP\n    @public\n    @function\n    @description Create the given directory(ies) using the given mode permissions\n    @param {String} dir The directory to create\n    @param {Number} mode The mode to give the created directory(ies)(Default: 0755)\n  */\n  this.mkdirP = function (dir, mode) {\n    let dirPath = path.normalize(dir);\n    let paths = dirPath.split(/\\/|\\\\/);\n    let currPath = '';\n    let next;\n\n    if (paths[0] == '' || /^[A-Za-z]+:/.test(paths[0])) {\n      currPath = paths.shift() || '/';\n      currPath = path.join(currPath, paths.shift());\n      //console.log('basedir');\n    }\n    while ((next = paths.shift())) {\n      if (next == '..') {\n        currPath = path.join(currPath, next);\n        continue;\n      }\n      currPath = path.join(currPath, next);\n      try {\n        //console.log('making ' + currPath);\n        fs.mkdirSync(currPath, mode || parseInt(755, 8));\n      }\n      catch(e) {\n        if (e.code != 'EEXIST') {\n          throw e;\n        }\n      }\n    }\n  };\n\n  /**\n    @name file#rmRf\n    @public\n    @function\n    @description Deletes the given directory/file\n    @param {String} p The path to delete, can be a directory or file\n  */\n  this.rmRf = function (p, options) {\n    let stat;\n    try {\n      stat = fs.lstatSync(p);\n      if (stat.isDirectory()) {\n        _rmDir(p);\n      }\n      else {\n        fs.unlinkSync(p);\n      }\n    }\n    catch (e) {}\n  };\n\n  /**\n    @name file#isAbsolute\n    @public\n    @function\n    @return {Boolean/String} If it's absolute the first character is returned otherwise false\n    @description Checks if a given path is absolute or relative\n    @param {String} p Path to check\n  */\n  this.isAbsolute = function (p) {\n    let match = /^[A-Za-z]+:\\\\|^\\//.exec(p);\n    if (match && match.length) {\n      return match[0];\n    }\n    return false;\n  };\n\n  /**\n    @name file#absolutize\n    @public\n    @function\n    @return {String} Returns the absolute path for the given path\n    @description Returns the absolute path for the given path\n    @param {String} p The path to get the absolute path for\n  */\n  this.absolutize = function (p) {\n    if (this.isAbsolute(p)) {\n      return p;\n    }\n    else {\n      return path.join(process.cwd(), p);\n    }\n  };\n\n})();\n\nmodule.exports = fileUtils;\n\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet fs = require('fs');\nlet parseargs = require('./parseargs');\nlet utils = require('./utils');\nlet Program;\nlet usage = require('fs').readFileSync(`${__dirname}/../usage.txt`).toString();\nlet { Task } = require('./task/task');\n\nfunction die(msg) {\n  console.log(msg);\n  process.stdout.write('', function () {\n    process.stderr.write('', function () {\n      process.exit();\n    });\n  });\n}\n\nlet preempts = {\n  version: function () {\n    die(jake.version);\n  },\n  help: function () {\n    die(usage);\n  }\n};\n\nlet AVAILABLE_OPTS = [\n  { full: 'jakefile',\n    abbr: 'f',\n    expectValue: true\n  },\n  { full: 'quiet',\n    abbr: 'q',\n    expectValue: false\n  },\n  { full: 'directory',\n    abbr: 'C',\n    expectValue: true\n  },\n  { full: 'always-make',\n    abbr: 'B',\n    expectValue: false\n  },\n  { full: 'tasks',\n    abbr: 'T',\n    expectValue: false,\n    allowValue: true\n  },\n  // Alias t\n  { full: 'tasks',\n    abbr: 't',\n    expectValue: false,\n    allowValue: true\n  },\n  // Alias ls\n  { full: 'tasks',\n    abbr: 'ls',\n    expectValue: false,\n    allowValue: true\n  },\n  { full: 'help',\n    abbr: 'h',\n  },\n  { full: 'version',\n    abbr: 'V',\n  },\n  // Alias lowercase v\n  { full: 'version',\n    abbr: 'v',\n  },\n  { full: 'jakelibdir',\n    abbr: 'J',\n    expectValue: true\n  },\n  { full: 'allow-rejection',\n    abbr: 'ar',\n    expectValue: false\n  }\n];\n\nProgram = function () {\n  this.availableOpts = AVAILABLE_OPTS;\n  this.opts = {};\n  this.taskNames = null;\n  this.taskArgs = null;\n  this.envVars = null;\n  this.die = die;\n};\n\nProgram.prototype = new (function () {\n\n  this.handleErr = function (err) {\n    if (jake.listeners('error').length !== 0) {\n      jake.emit('error', err);\n      return;\n    }\n\n    if (jake.listeners('error').length) {\n      jake.emit('error', err);\n      return;\n    }\n\n    utils.logger.error('jake aborted.');\n    if (err.stack) {\n      utils.logger.error(err.stack);\n    }\n    else {\n      utils.logger.error(err.message);\n    }\n\n    process.stdout.write('', function () {\n      process.stderr.write('', function () {\n        jake.errorCode = jake.errorCode || 1;\n        process.exit(jake.errorCode);\n      });\n    });\n  };\n\n  this.parseArgs = function (args) {\n    let result = (new parseargs.Parser(this.availableOpts)).parse(args);\n    this.setOpts(result.opts);\n    this.setTaskNames(result.taskNames);\n    this.setEnvVars(result.envVars);\n  };\n\n  this.setOpts = function (options) {\n    let opts = options || {};\n    Object.assign(this.opts, opts);\n  };\n\n  this.internalOpts = function (options) {\n    this.availableOpts = this.availableOpts.concat(options);\n  };\n\n  this.autocompletions = function (cur) {\n    let p; let i; let task;\n    let commonPrefix = '';\n    let matches = [];\n\n    for (p in jake.Task) {\n      task = jake.Task[p];\n      if (\n        'fullName' in task\n          && (\n            // if empty string, program converts to true\n            cur === true ||\n            task.fullName.indexOf(cur) === 0\n          )\n      ) {\n        if (matches.length === 0) {\n          commonPrefix = task.fullName;\n        }\n        else {\n          for (i = commonPrefix.length; i > -1; --i) {\n            commonPrefix = commonPrefix.substr(0, i);\n            if (task.fullName.indexOf(commonPrefix) === 0) {\n              break;\n            }\n          }\n        }\n        matches.push(task.fullName);\n      }\n    }\n\n    if (matches.length > 1 && commonPrefix === cur) {\n      matches.unshift('yes-space');\n    }\n    else {\n      matches.unshift('no-space');\n    }\n\n    process.stdout.write(matches.join(' '));\n  };\n\n  this.setTaskNames = function (names) {\n    if (names && !Array.isArray(names)) {\n      throw new Error('Task names must be an array');\n    }\n    this.taskNames = (names && names.length) ? names : ['default'];\n  };\n\n  this.setEnvVars = function (vars) {\n    this.envVars = vars || null;\n  };\n\n  this.firstPreemptiveOption = function () {\n    let opts = this.opts;\n    for (let p in opts) {\n      if (preempts[p]) {\n        return preempts[p];\n      }\n    }\n    return false;\n  };\n\n  this.init = function (configuration) {\n    let self = this;\n    let config = configuration || {};\n    if (config.options) {\n      this.setOpts(config.options);\n    }\n    if (config.taskNames) {\n      this.setTaskNames(config.taskNames);\n    }\n    if (config.envVars) {\n      this.setEnvVars(config.envVars);\n    }\n    process.addListener('uncaughtException', function (err) {\n      self.handleErr(err);\n    });\n    if (!this.opts['allow-rejection']) {\n      process.addListener('unhandledRejection', (reason, promise) => {\n        utils.logger.error('Unhandled rejection at:', promise, 'reason:', reason);\n        self.handleErr(reason);\n      });\n    }\n    if (this.envVars) {\n      Object.assign(process.env, this.envVars);\n    }\n  };\n\n  this.run = function () {\n    let rootTask;\n    let taskNames;\n    let dirname;\n    let opts = this.opts;\n\n    if (opts.autocomplete) {\n      return this.autocompletions(opts['autocomplete-cur'], opts['autocomplete-prev']);\n    }\n    // Run with `jake -T`, just show descriptions\n    if (opts.tasks) {\n      return jake.showAllTaskDescriptions(opts.tasks);\n    }\n\n    taskNames = this.taskNames;\n    if (!(Array.isArray(taskNames) && taskNames.length)) {\n      throw new Error('Please pass jake.runTasks an array of task-names');\n    }\n\n    // Set working dir\n    dirname = opts.directory;\n    if (dirname) {\n      if (fs.existsSync(dirname) &&\n        fs.statSync(dirname).isDirectory()) {\n        process.chdir(dirname);\n      }\n      else {\n        throw new Error(dirname + ' is not a valid directory path');\n      }\n    }\n\n    rootTask = task(Task.ROOT_TASK_NAME, taskNames, function () {});\n    rootTask._internal = true;\n\n    rootTask.once('complete', function () {\n      jake.emit('complete');\n    });\n    jake.emit('start');\n    rootTask.invoke();\n  };\n\n})();\n\nmodule.exports.Program = Program;\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet parseargs = {};\nlet isOpt = function (arg) { return arg.indexOf('-') === 0 };\nlet removeOptPrefix = function (opt) { return opt.replace(/^--/, '').replace(/^-/, '') };\n\n/**\n * @constructor\n * Parses a list of command-line args into a key/value object of\n * options and an array of positional commands.\n * @ param {Array} opts A list of options in the following format:\n * [{full: 'foo', abbr: 'f'}, {full: 'bar', abbr: 'b'}]]\n */\nparseargs.Parser = function (opts) {\n  // A key/value object of matching options parsed out of the args\n  this.opts = {};\n  this.taskNames = null;\n  this.envVars = null;\n\n  // Data structures used for parsing\n  this.reg = opts;\n  this.shortOpts = {};\n  this.longOpts = {};\n\n  let self = this;\n  [].forEach.call(opts, function (item) {\n    self.shortOpts[item.abbr] = item;\n    self.longOpts[item.full] = item;\n  });\n};\n\nparseargs.Parser.prototype = new function () {\n\n  let _trueOrNextVal = function (argParts, args) {\n    if (argParts[1]) {\n      return argParts[1];\n    }\n    else {\n      return (!args[0] || isOpt(args[0])) ?\n        true : args.shift();\n    }\n  };\n\n  /**\n   * Parses an array of arguments into options and positional commands\n   * @param {Array} args The command-line args to parse\n   */\n  this.parse = function (args) {\n    let cmds = [];\n    let cmd;\n    let envVars = {};\n    let opts = {};\n    let arg;\n    let argItem;\n    let argParts;\n    let cmdItems;\n    let taskNames = [];\n    let preempt;\n\n    while (args.length) {\n      arg = args.shift();\n\n      if (isOpt(arg)) {\n        arg = removeOptPrefix(arg);\n        argParts = arg.split('=');\n        argItem = this.longOpts[argParts[0]] || this.shortOpts[argParts[0]];\n        if (argItem) {\n          // First-encountered preemptive opt takes precedence -- no further opts\n          // or possibility of ambiguity, so just look for a value, or set to\n          // true and then bail\n          if (argItem.preempts) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            preempt = true;\n            break;\n          }\n          // If the opt requires a value, see if we can get a value from the\n          // next arg, or infer true from no-arg -- if it's followed by another\n          // opt, throw an error\n          if (argItem.expectValue || argItem.allowValue) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            if (argItem.expectValue && !opts[argItem.full]) {\n              throw new Error(argItem.full + ' option expects a value.');\n            }\n          }\n          else {\n            opts[argItem.full] = true;\n          }\n        }\n      }\n      else {\n        cmds.unshift(arg);\n      }\n    }\n\n    if (!preempt) {\n      // Parse out any env-vars and task-name\n      while ((cmd = cmds.pop())) {\n        cmdItems = cmd.split('=');\n        if (cmdItems.length > 1) {\n          envVars[cmdItems[0]] = cmdItems[1];\n        }\n        else {\n          taskNames.push(cmd);\n        }\n      }\n\n    }\n\n    return {\n      opts: opts,\n      envVars: envVars,\n      taskNames: taskNames\n    };\n  };\n\n};\n\nmodule.exports = parseargs;\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet path = require('path');\nlet fs = require('fs');\nlet existsSync = fs.existsSync;\nlet utils = require('./utils');\n\n// Files like jakelib/foobar.jake.js\nconst JAKELIB_FILE_PAT = /\\.jake$|\\.js$/;\nconst SUPPORTED_EXTENSIONS = {\n  'js': null,\n  'coffee': function () {\n    try {\n      let cs = require('coffeescript');\n      if (typeof cs.register == 'function') {\n        cs.register();\n      }\n    }\n    catch(e) {\n      throw new Error('You have a CoffeeScript Jakefile, but have not installed CoffeeScript');\n    }\n  },\n  'ls': function () {\n    try {\n      require('livescript');\n    }\n    catch (e) {\n      throw new Error('You have a LiveScript Jakefile, but have not installed LiveScript');\n    }\n  }\n};\nconst IMPLICIT_JAKEFILE_NAMES = [\n  'Jakefile',\n  'Gulpfile'\n];\n\nlet Loader = function () {\n  // Load a Jakefile, running the code inside -- this may result in\n  // tasks getting defined using the original Jake API, e.g.,\n  // `task('foo' ['bar', 'baz']);`, or can also auto-create tasks\n  // from any functions exported from the file\n  function loadFile(filePath) {\n    let exported = require(filePath);\n    for (let [key, value] of Object.entries(exported)) {\n      let t;\n      if (typeof value == 'function') {\n        t = jake.task(key, value);\n        t.description = '(Exported function)';\n      }\n    }\n  }\n\n  function fileExists(name) {\n    let nameWithExt = null;\n    // Support no file extension as well\n    let exts = Object.keys(SUPPORTED_EXTENSIONS).concat(['']);\n    exts.some((ext) => {\n      let fname = ext ? `${name}.${ext}` : name;\n      if (existsSync(fname)) {\n        nameWithExt = fname;\n        return true;\n      }\n    });\n    return nameWithExt;\n  }\n\n  // Recursive\n  function findImplicitJakefile() {\n    let cwd = process.cwd();\n    let names = IMPLICIT_JAKEFILE_NAMES;\n    let found = null;\n    names.some((name) => {\n      let n;\n      // Prefer all-lowercase\n      n = name.toLowerCase();\n      if ((found = fileExists(n))) {\n        return found;\n      }\n      // Check mixed-case as well\n      n = name;\n      if ((found = fileExists(n))) {\n        return found;\n      }\n    });\n    if (found) {\n      return found;\n    }\n    else {\n      process.chdir(\"..\");\n      // If we've walked all the way up the directory tree,\n      // bail out with no result\n      if (cwd === process.cwd()) {\n        return null;\n      }\n      return findImplicitJakefile();\n    }\n  }\n\n  this.loadFile = function (fileSpecified) {\n    let jakefile;\n    let origCwd = process.cwd();\n\n    if (fileSpecified) {\n      if (existsSync(fileSpecified)) {\n        jakefile = fileSpecified;\n      }\n    }\n    else {\n      jakefile = findImplicitJakefile();\n    }\n\n    if (jakefile) {\n      let ext = jakefile.split('.')[1];\n      let loaderFunc = SUPPORTED_EXTENSIONS[ext];\n      loaderFunc && loaderFunc();\n\n      loadFile(utils.file.absolutize(jakefile));\n      return true;\n    }\n    else {\n      if (!fileSpecified) {\n        // Restore the working directory on failure\n        process.chdir(origCwd);\n      }\n      return false;\n    }\n  };\n\n  this.loadDirectory = function (d) {\n    let dirname = d || 'jakelib';\n    let dirlist;\n    dirname = utils.file.absolutize(dirname);\n    if (existsSync(dirname)) {\n      dirlist = fs.readdirSync(dirname);\n      dirlist.forEach(function (filePath) {\n        if (JAKELIB_FILE_PAT.test(filePath)) {\n          loadFile(path.join(dirname, filePath));\n        }\n      });\n      return true;\n    }\n    return false;\n  };\n\n};\n\nmodule.exports = function () {\n  return new Loader();\n};\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet path = require('path');\nlet fs = require('fs');\nlet exec = require('child_process').exec;\nlet FileList = require('filelist').FileList;\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.PackageTask\n  @constructor\n  @description Instantiating a PackageTask creates a number of Jake\n  Tasks that make packaging and distributing your software easy.\n\n  @param {String} name The name of the project\n  @param {String} version The current project version (will be\n  appended to the project-name in the package-archive\n  @param {Function} definition Defines the contents of the package,\n  and format of the package-archive. Will be executed on the instantiated\n  PackageTask (i.e., 'this', will be the PackageTask instance),\n  to set the various instance-propertiess.\n\n  @example\n  let t = new jake.PackageTask('rous', 'v' + version, function () {\n    let files = [\n      'Capfile'\n    , 'Jakefile'\n    , 'README.md'\n    , 'package.json'\n    , 'app/*'\n    , 'bin/*'\n    , 'config/*'\n    , 'lib/*'\n    , 'node_modules/*'\n    ];\n    this.packageFiles.include(files);\n    this.packageFiles.exclude('node_modules/foobar');\n    this.needTarGz = true;\n  });\n\n */\nlet PackageTask = function () {\n  let args = Array.prototype.slice.call(arguments);\n  let name = args.shift();\n  let version = args.shift();\n  let definition = args.pop();\n  let prereqs = args.pop() || []; // Optional\n\n  prereqs = [].concat(prereqs); // Accept string or list\n\n  /**\n    @name jake.PackageTask#name\n    @public\n    @type {String}\n    @description The name of the project\n   */\n  this.name = name;\n  /**\n    @name jake.PackageTask#version\n    @public\n    @type {String}\n    @description The project version-string\n   */\n  this.version = version;\n  /**\n    @name jake.PackageTask#prereqs\n    @public\n    @type {Array}\n    @description Tasks to run before packaging\n   */\n  this.prereqs = prereqs;\n  /**\n    @name jake.PackageTask#packageDir\n    @public\n    @type {String='pkg'}\n    @description The directory-name to use for packaging the software\n   */\n  this.packageDir = 'pkg';\n  /**\n    @name jake.PackageTask#packageFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files and directories to include in the\n    package-archive\n   */\n  this.packageFiles = new FileList();\n  /**\n    @name jake.PackageTask#needTar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tgz archive of the package\n   */\n  this.needTar = false;\n  /**\n    @name jake.PackageTask#needTarGz\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tar.gz archive of the package\n   */\n  this.needTarGz = false;\n  /**\n    @name jake.PackageTask#needTarBz2\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a bzip2 .bz2 archive of the package\n   */\n  this.needTarBz2 = false;\n  /**\n    @name jake.PackageTask#needJar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `jar` utility to create\n    a .jar archive of the package\n   */\n  this.needJar = false;\n  /**\n    @name jake.PackageTask#needZip\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `zip` utility to create\n    a .zip archive of the package\n   */\n  this.needZip = false;\n  /**\n    @name jake.PackageTask#manifestFile\n    @public\n    @type {String=null}\n    @description Can be set to point the `jar` utility at a manifest\n    file to use in a .jar archive. If unset, one will be automatically\n    created by the `jar` utility. This path should be relative to the\n    root of the package directory (this.packageDir above, likely 'pkg')\n   */\n  this.manifestFile = null;\n  /**\n    @name jake.PackageTask#tarCommand\n    @public\n    @type {String='tar'}\n    @description The shell-command to use for creating tar archives.\n   */\n  this.tarCommand = 'tar';\n  /**\n    @name jake.PackageTask#jarCommand\n    @public\n    @type {String='jar'}\n    @description The shell-command to use for creating jar archives.\n   */\n  this.jarCommand = 'jar';\n  /**\n    @name jake.PackageTask#zipCommand\n    @public\n    @type {String='zip'}\n    @description The shell-command to use for creating zip archives.\n   */\n  this.zipCommand = 'zip';\n  /**\n    @name jake.PackageTask#archiveNoBaseDir\n    @public\n    @type {Boolean=false}\n    @description Simple option for performing the archive on the\n    contents of the directory instead of the directory itself\n   */\n  this.archiveNoBaseDir = false;\n  /**\n    @name jake.PackageTask#archiveChangeDir\n    @public\n    @type {String=null}\n    @description Equivalent to the '-C' command for the `tar` and `jar`\n    commands. (\"Change to this directory before adding files.\")\n   */\n  this.archiveChangeDir = null;\n  /**\n    @name jake.PackageTask#archiveContentDir\n    @public\n    @type {String=null}\n    @description Specifies the files and directories to include in the\n    package-archive. If unset, this will default to the main package\n    directory -- i.e., name + version.\n   */\n  this.archiveContentDir = null;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n  this.define();\n};\n\nPackageTask.prototype = new (function () {\n\n  let _compressOpts = {\n    Tar: {\n      ext: '.tgz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarGz: {\n      ext: '.tar.gz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarBz2: {\n      ext: '.tar.bz2',\n      flags: 'cjf',\n      cmd: 'tar'\n    },\n    Jar: {\n      ext: '.jar',\n      flags: 'cf',\n      cmd: 'jar'\n    },\n    Zip: {\n      ext: '.zip',\n      flags: 'qr',\n      cmd: 'zip'\n    }\n  };\n\n  this.define = function () {\n    let self = this;\n    let packageDirPath = this.packageDirPath();\n    let compressTaskArr = [];\n\n    desc('Build the package for distribution');\n    task('package', self.prereqs.concat(['clobberPackage', 'buildPackage']));\n    // Backward-compat alias\n    task('repackage', ['package']);\n\n    task('clobberPackage', function () {\n      jake.rmRf(self.packageDir, {silent: true});\n    });\n\n    desc('Remove the package');\n    task('clobber', ['clobberPackage']);\n\n    let doCommand = function (p) {\n      let filename = path.resolve(self.packageDir + '/' + self.packageName() +\n                                  _compressOpts[p].ext);\n      if (process.platform == 'win32') {\n        // Windows full path may have drive letter, which is going to cause\n        // namespace problems, so strip it.\n        if (filename.length > 2 && filename[1] == ':') {\n          filename = filename.substr(2);\n        }\n      }\n      compressTaskArr.push(filename);\n\n      file(filename, [packageDirPath], function () {\n        let cmd;\n        let opts = _compressOpts[p];\n        // Directory to move to when doing the compression-task\n        // Changes in the case of zip for emulating -C option\n        let chdir = self.packageDir;\n        // Save the current dir so it's possible to pop back up\n        // after compressing\n        let currDir = process.cwd();\n        let archiveChangeDir;\n        let archiveContentDir;\n\n        if (self.archiveNoBaseDir) {\n          archiveChangeDir = self.packageName();\n          archiveContentDir = '.';\n        }\n        else {\n          archiveChangeDir = self.archiveChangeDir;\n          archiveContentDir = self.archiveContentDir;\n        }\n\n        cmd = self[opts.cmd + 'Command'];\n        cmd += ' -' + opts.flags;\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += 'm';\n        }\n\n        // The name of the archive to create -- use full path\n        // so compression can be performed from a different dir\n        // if needed\n        cmd += ' ' + filename;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += ' ' + self.manifestFile;\n        }\n\n        // Where to perform the compression -- -C option isn't\n        // supported in zip, so actually do process.chdir for this\n        if (archiveChangeDir) {\n          if (opts.cmd == 'zip') {\n            chdir = path.join(chdir, archiveChangeDir);\n          }\n          else {\n            cmd += ' -C ' + archiveChangeDir;\n          }\n        }\n\n        // Where to get the archive content\n        if (archiveContentDir) {\n          cmd += ' ' + archiveContentDir;\n        }\n        else {\n          cmd += ' ' + self.packageName();\n        }\n\n        // Move into the desired dir (usually packageDir) to compress\n        // Return back up to the current dir after the exec\n        process.chdir(chdir);\n\n        exec(cmd, function (err, stdout, stderr) {\n          if (err) { throw err; }\n\n          // Return back up to the starting directory (see above,\n          // before exec)\n          process.chdir(currDir);\n\n          complete();\n        });\n      }, {async: true});\n    };\n\n    for (let p in _compressOpts) {\n      if (this['need' + p]) {\n        doCommand(p);\n      }\n    }\n\n    task('buildPackage', compressTaskArr, function () {});\n\n    directory(this.packageDir);\n\n    file(packageDirPath, this.packageFiles, function () {\n      jake.mkdirP(packageDirPath);\n      let fileList = [];\n      self.packageFiles.forEach(function (name) {\n        let f = path.join(self.packageDirPath(), name);\n        let fDir = path.dirname(f);\n        jake.mkdirP(fDir, {silent: true});\n\n        // Add both files and directories\n        fileList.push({\n          from: name,\n          to: f\n        });\n      });\n      let _copyFile = function () {\n        let file = fileList.pop();\n        let stat;\n        if (file) {\n          stat = fs.statSync(file.from);\n          // Target is a directory, just create it\n          if (stat.isDirectory()) {\n            jake.mkdirP(file.to, {silent: true});\n            _copyFile();\n          }\n          // Otherwise copy the file\n          else {\n            jake.cpR(file.from, file.to, {silent: true});\n            _copyFile();\n          }\n        }\n        else {\n          complete();\n        }\n      };\n      _copyFile();\n    }, {async: true});\n\n\n  };\n\n  this.packageName = function () {\n    if (this.version) {\n      return this.name + '-' + this.version;\n    }\n    else {\n      return this.name;\n    }\n  };\n\n  this.packageDirPath = function () {\n    return this.packageDir + '/' + this.packageName();\n  };\n\n})();\n\njake.PackageTask = PackageTask;\nexports.PackageTask = PackageTask;\n\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet fs = require('fs');\nlet path = require('path');\nlet exec = require('child_process').execSync;\nlet FileList = require('filelist').FileList;\n\nlet PublishTask = function () {\n  let args = Array.prototype.slice.call(arguments).filter(function (item) {\n    return typeof item != 'undefined';\n  });\n  let arg;\n  let opts = {};\n  let definition;\n  let prereqs = [];\n  let createDef = function (arg) {\n    return function () {\n      this.packageFiles.include(arg);\n    };\n  };\n\n  this.name = args.shift();\n\n  // Old API, just name + list of files\n  if (args.length == 1 && (Array.isArray(args[0]) || typeof args[0] == 'string')) {\n    definition = createDef(args.pop());\n  }\n  // Current API, name + [prereqs] + [opts] + definition\n  else {\n    while ((arg = args.pop())) {\n      // Definition func\n      if (typeof arg == 'function') {\n        definition = arg;\n      }\n      // Prereqs\n      else if (Array.isArray(arg) || typeof arg == 'string') {\n        prereqs = arg;\n      }\n      // Opts\n      else {\n        opts = arg;\n      }\n    }\n  }\n\n  this.prereqs = prereqs;\n  this.packageFiles = new FileList();\n  this.publishCmd = opts.publishCmd || 'npm publish %filename';\n  this.publishMessage = opts.publishMessage || 'BOOM! Published.';\n  this.gitCmd = opts.gitCmd || 'git';\n  this.versionFiles = opts.versionFiles || ['package.json'];\n  this.scheduleDelay = 5000;\n\n  // Override utility funcs for testing\n  this._ensureRepoClean = function (stdout) {\n    if (stdout.length) {\n      fail(new Error('Git repository is not clean.'));\n    }\n  };\n  this._getCurrentBranch = function (stdout) {\n    return String(stdout).trim();\n  };\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n  this.define();\n};\n\n\nPublishTask.prototype = new (function () {\n\n  let _currentBranch = null;\n\n  let getPackage = function () {\n    let pkg = JSON.parse(fs.readFileSync(path.join(process.cwd(),\n      '/package.json')).toString());\n    return pkg;\n  };\n  let getPackageVersionNumber = function () {\n    return getPackage().version;\n  };\n\n  this.define = function () {\n    let self = this;\n\n    namespace('publish', function () {\n      task('fetchTags', function () {\n        // Make sure local tags are up to date\n        exec(self.gitCmd + ' fetch --tags');\n        console.log('Fetched remote tags.');\n      });\n\n      task('getCurrentBranch', function () {\n        // Figure out what branch to push to\n        let stdout = exec(self.gitCmd + ' symbolic-ref --short HEAD').toString();\n        if (!stdout) {\n          throw new Error('No current Git branch found');\n        }\n        _currentBranch = self._getCurrentBranch(stdout);\n        console.log('On branch ' + _currentBranch);\n      });\n\n      task('ensureClean', function () {\n        // Only bump, push, and tag if the Git repo is clean\n        let stdout = exec(self.gitCmd + ' status --porcelain --untracked-files=no').toString();\n        // Throw if there's output\n        self._ensureRepoClean(stdout);\n      });\n\n      task('updateVersionFiles', function () {\n        let pkg;\n        let version;\n        let arr;\n        let patch;\n\n        // Grab the current version-string\n        pkg = getPackage();\n        version = pkg.version;\n        // Increment the patch-number for the version\n        arr = version.split('.');\n        patch = parseInt(arr.pop(), 10) + 1;\n        arr.push(patch);\n        version = arr.join('.');\n\n        // Update package.json or other files with the new version-info\n        self.versionFiles.forEach(function (file) {\n          let p = path.join(process.cwd(), file);\n          let data = JSON.parse(fs.readFileSync(p).toString());\n          data.version = version;\n          fs.writeFileSync(p, JSON.stringify(data, true, 2) + '\\n');\n        });\n        // Return the version string so that listeners for the 'complete' event\n        // for this task can use it (e.g., to update other files before pushing\n        // to Git)\n        return version;\n      });\n\n      task('pushVersion', ['ensureClean', 'updateVersionFiles'], function () {\n        let version = getPackageVersionNumber();\n        let message = 'Version ' + version;\n        let cmds = [\n          self.gitCmd + ' commit -a -m \"' + message + '\"',\n          self.gitCmd + ' push origin ' + _currentBranch,\n          self.gitCmd + ' tag -a v' + version + ' -m \"' + message + '\"',\n          self.gitCmd + ' push --tags'\n        ];\n        cmds.forEach((cmd) => {\n          exec(cmd);\n        });\n        version = getPackageVersionNumber();\n        console.log('Bumped version number to v' + version + '.');\n      });\n\n      let defineTask = task('definePackage', function () {\n        let version = getPackageVersionNumber();\n        new jake.PackageTask(self.name, 'v' + version, self.prereqs, function () {\n          // Replace the PackageTask's FileList with the PublishTask's FileList\n          this.packageFiles = self.packageFiles;\n          this.needTarGz = true; // Default to tar.gz\n          // If any of the need<CompressionFormat> or archive opts are set\n          // proxy them to the PackageTask\n          for (let p in this) {\n            if (p.indexOf('need') === 0 || p.indexOf('archive') === 0) {\n              if (typeof self[p] != 'undefined') {\n                this[p] = self[p];\n              }\n            }\n          }\n        });\n      });\n      defineTask._internal = true;\n\n      task('package', function () {\n        let definePack = jake.Task['publish:definePackage'];\n        let pack = jake.Task['package'];\n        let version = getPackageVersionNumber();\n\n        // May have already been run\n        if (definePack.taskStatus == jake.Task.runStatuses.DONE) {\n          definePack.reenable(true);\n        }\n        definePack.invoke();\n        // Set manually, completion happens in next tick, creating deadlock\n        definePack.taskStatus = jake.Task.runStatuses.DONE;\n        pack.invoke();\n        console.log('Created package for ' + self.name + ' v' + version);\n      });\n\n      task('publish', function () {\n        return new Promise((resolve) => {\n          let version = getPackageVersionNumber();\n          let filename;\n          let cmd;\n\n          console.log('Publishing ' + self.name + ' v' + version);\n\n          if (typeof self.createPublishCommand == 'function') {\n            cmd = self.createPublishCommand(version);\n          }\n          else {\n            filename = './pkg/' + self.name + '-v' + version + '.tar.gz';\n            cmd = self.publishCmd.replace(/%filename/gi, filename);\n          }\n\n          if (typeof cmd == 'function') {\n            cmd(function (err) {\n              if (err) {\n                throw err;\n              }\n              console.log(self.publishMessage);\n              resolve();\n            });\n          }\n          else {\n            // Hackity hack -- NPM publish sometimes returns errror like:\n            // Error sending version data\\nnpm ERR!\n            // Error: forbidden 0.2.4 is modified, should match modified time\n            setTimeout(function () {\n              let stdout = exec(cmd).toString() || '';\n              stdout = stdout.trim();\n              if (stdout) {\n                console.log(stdout);\n              }\n              console.log(self.publishMessage);\n              resolve();\n            }, self.scheduleDelay);\n          }\n        });\n      });\n\n      task('cleanup', function () {\n        return new Promise((resolve) => {\n          let clobber = jake.Task.clobber;\n          clobber.reenable(true);\n          clobber.on('complete', function () {\n            console.log('Cleaned up package');\n            resolve();\n          });\n          clobber.invoke();\n        });\n      });\n\n    });\n\n    let prefixNs = function (item) {\n      return 'publish:' + item;\n    };\n\n    // Create aliases in the default namespace\n    desc('Create a new version and release.');\n    task('publish', self.prereqs.concat(['version', 'release']\n      .map(prefixNs)));\n\n    desc('Release the existing version.');\n    task('publishExisting', self.prereqs.concat(['release']\n      .map(prefixNs)));\n\n    task('version', ['fetchTags', 'getCurrentBranch', 'pushVersion']\n      .map(prefixNs));\n\n    task('release', ['package', 'publish', 'cleanup']\n      .map(prefixNs));\n\n    // Invoke proactively so there will be a callable 'package' task\n    // which can be used apart from 'publish'\n    jake.Task['publish:definePackage'].invoke();\n  };\n\n})();\n\njake.PublishTask = PublishTask;\nexports.PublishTask = PublishTask;\n\n","/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet path = require('path');\nlet currDir = process.cwd();\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.TestTask\n  @constructor\n  @description Instantiating a TestTask creates a number of Jake\n  Tasks that make running tests for your software easy.\n\n  @param {String} name The name of the project\n  @param {Function} definition Defines the list of files containing the tests,\n  and the name of the namespace/task for running them. Will be executed on the\n  instantiated TestTask (i.e., 'this', will be the TestTask instance), to set\n  the various instance-propertiess.\n\n  @example\n  let t = new jake.TestTask('bij-js', function () {\n    this.testName = 'testSpecial';\n    this.testFiles.include('test/**');\n  });\n\n */\nlet TestTask = function () {\n  let self = this;\n  let args = Array.prototype.slice.call(arguments);\n  let name = args.shift();\n  let definition = args.pop();\n  let prereqs = args.pop() || [];\n\n  /**\n    @name jake.TestTask#testNam\n    @public\n    @type {String}\n    @description The name of the namespace to place the tests in, and\n    the top-level task for running tests. Defaults to \"test\"\n   */\n  this.testName = 'test';\n\n  /**\n    @name jake.TestTask#testFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files containing tests to load\n   */\n  this.testFiles = new jake.FileList();\n\n  /**\n    @name jake.TestTask#showDescription\n    @public\n    @type {Boolean}\n    @description Show the created task when doing Jake -T\n   */\n  this.showDescription = true;\n\n  /*\n    @name jake.TestTask#totalTests\n    @public\n    @type {Number}\n    @description The total number of tests to run\n  */\n  this.totalTests = 0;\n\n  /*\n    @name jake.TestTask#executedTests\n    @public\n    @type {Number}\n    @description The number of tests successfully run\n  */\n  this.executedTests = 0;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n\n  if (this.showDescription) {\n    desc('Run the tests for ' + name);\n  }\n\n  task(this.testName, prereqs, {async: true}, function () {\n    let t = jake.Task[this.fullName + ':run'];\n    t.on('complete', function () {\n      complete();\n    });\n    // Pass args to the namespaced test\n    t.invoke.apply(t, arguments);\n  });\n\n  namespace(self.testName, function () {\n\n    let runTask = task('run', {async: true}, function (pat) {\n      let re;\n      let testFiles;\n\n      // Don't nest; make a top-level namespace. Don't want\n      // re-calling from inside to nest infinitely\n      jake.currentNamespace = jake.defaultNamespace;\n\n      re = new RegExp(pat);\n      // Get test files that match the passed-in pattern\n      testFiles = self.testFiles.toArray()\n        .filter(function (f) {\n          return (re).test(f);\n        }) // Don't load the same file multiple times -- should this be in FileList?\n        .reduce(function (p, c) {\n          if (p.indexOf(c) < 0) {\n            p.push(c);\n          }\n          return p;\n        }, []);\n\n      // Create a namespace for all the testing tasks to live in\n      namespace(self.testName + 'Exec', function () {\n        // Each test will be a prereq for the dummy top-level task\n        let prereqs = [];\n        // Continuation to pass to the async tests, wrapping `continune`\n        let next = function () {\n          complete();\n        };\n        // Create the task for this test-function\n        let createTask = function (name, action) {\n          // If the test-function is defined with a continuation\n          // param, flag the task as async\n          let t;\n          let isAsync = !!action.length;\n\n          // Define the actual namespaced task with the name, the\n          // wrapped action, and the correc async-flag\n          t = task(name, createAction(name, action), {\n            async: isAsync\n          });\n          t.once('complete', function () {\n            self.executedTests++;\n          });\n          t._internal = true;\n          return t;\n        };\n        // Used as the action for the defined task for each test.\n        let createAction = function (n, a) {\n          // A wrapped function that passes in the `next` function\n          // for any tasks that run asynchronously\n          return function () {\n            let cb;\n            if (a.length) {\n              cb = next;\n            }\n            if (!(n == 'before' || n == 'after' ||\n                    /_beforeEach$/.test(n) || /_afterEach$/.test(n))) {\n              jake.logger.log(n);\n            }\n            // 'this' will be the task when action is run\n            return a.call(this, cb);\n          };\n        };\n          // Dummy top-level task for everything to be prereqs for\n        let topLevel;\n\n        // Pull in each test-file, and iterate over any exported\n        // test-functions. Register each test-function as a prereq task\n        testFiles.forEach(function (file) {\n          let exp = require(path.join(currDir, file));\n\n          // Create a namespace for each filename, so test-name collisions\n          // won't be a problem\n          namespace(file, function () {\n            let testPrefix = self.testName + 'Exec:' + file + ':';\n            let testName;\n            // Dummy task for displaying file banner\n            testName = '*** Running ' + file + ' ***';\n            prereqs.push(testPrefix + testName);\n            createTask(testName, function () {});\n\n            // 'before' setup\n            if (typeof exp.before == 'function') {\n              prereqs.push(testPrefix + 'before');\n              // Create the task\n              createTask('before', exp.before);\n            }\n\n            // Walk each exported function, and create a task for each\n            for (let p in exp) {\n              if (p == 'before' || p == 'after' ||\n                  p == 'beforeEach' || p == 'afterEach') {\n                continue;\n              }\n\n              if (typeof exp.beforeEach == 'function') {\n                prereqs.push(testPrefix + p + '_beforeEach');\n                // Create the task\n                createTask(p + '_beforeEach', exp.beforeEach);\n              }\n\n              // Add the namespace:name of this test to the list of prereqs\n              // for the dummy top-level task\n              prereqs.push(testPrefix + p);\n              // Create the task\n              createTask(p, exp[p]);\n\n              if (typeof exp.afterEach == 'function') {\n                prereqs.push(testPrefix + p + '_afterEach');\n                // Create the task\n                createTask(p + '_afterEach', exp.afterEach);\n              }\n            }\n\n            // 'after' teardown\n            if (typeof exp.after == 'function') {\n              prereqs.push(testPrefix + 'after');\n              // Create the task\n              let afterTask = createTask('after', exp.after);\n              afterTask._internal = true;\n            }\n\n          });\n        });\n\n        self.totalTests = prereqs.length;\n        process.on('exit', function () {\n          // Throw in the case where the process exits without\n          // finishing tests, but no error was thrown\n          if (!jake.errorCode && (self.totalTests > self.executedTests)) {\n            throw new Error('Process exited without all tests completing.');\n          }\n        });\n\n        // Create the dummy top-level task. When calling a task internally\n        // with `invoke` that is async (or has async prereqs), have to listen\n        // for the 'complete' event to know when it's done\n        topLevel = task('__top__', prereqs);\n        topLevel._internal = true;\n        topLevel.addListener('complete', function () {\n          jake.logger.log('All tests ran successfully');\n          complete();\n        });\n\n        topLevel.invoke(); // Do the thing!\n      });\n\n    });\n    runTask._internal = true;\n\n  });\n\n\n};\n\njake.TestTask = TestTask;\nexports.TestTask = TestTask;\n\n"]}